<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Netty 源码分析（三） - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="Netty 源码分析（三）"><meta property="og:url" content="https://blog.cuzz.site/2019/01/16/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://picsum.photos/558/302"><meta property="article:published_time" content="2019-01-16T14:24:12.000Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="源码"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://picsum.photos/558/302"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cuzz.site/2019/01/16/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"},"headline":"cuzz's blog","image":[],"datePublished":"2019-01-16T14:24:12.000Z","author":{"@type":"Person","name":"John Doe"},"description":"版本 4.1.15    官网：https:&#x2F;&#x2F;netty.io&#x2F;  Netty is an asynchronous event-driven network application framework  for rapid development of maintainable high performance protocol servers &amp; clients."}</script><link rel="canonical" href="https://blog.cuzz.site/2019/01/16/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://unpkg.com/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://unpkg.com/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://unpkg.com/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://unpkg.com/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/likes">Likes</a><a class="navbar-item" href="/images">Images</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://picsum.photos/558/302" alt="Netty 源码分析（三）"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-16T14:24:12.000Z" title="2019-01-16T14:24:12.000Z">2019-01-16</time></span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">16 minutes read (About 2339 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Netty 源码分析（三）</h1><div class="content"><p>版本 4.1.15   </p>
<p>官网：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<blockquote>
<p>Netty is <em>an asynchronous event-driven network application framework</em>  for rapid development of maintainable high performance protocol servers &amp; clients. </p>
</blockquote>
<a id="more"></a>

<h2 id="addLast-方法"><a href="#addLast-方法" class="headerlink" title="addLast 方法"></a>addLast 方法</h2><p>io.netty.channel.DefaultChannelPipeline#addLast</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">            </span><br><span class="line">        addLast0(newCtx);  <span class="comment">// 是把 ChannelHandlerContext 添加进去</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractChannelHandlerContext</code> 定义了一个上下文，找到实现的一个接口 <code>ChannelHandlerContext</code></p>
<p>io.netty.channel.ChannelHandlerContext</p>
<p>文档：<a target="_blank" rel="noopener" href="https://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html">https://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html</a></p>
<p>接下来我分析一下 <code>ChannelHandlerContext</code> ，<code>PipeLine</code>，<code>Handler</code> 这三者的关系</p>
<p>这篇文章写的很清楚</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010853261/article/details/54574440">https://blog.csdn.net/u010853261/article/details/54574440</a></p>
<h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>每个<code>ChannelHandler</code>被添加到<code>ChannelPipeline</code>后，都会创建一个<code>ChannelHandlerContext</code>并与之创建的<code>ChannelHandler</code>关联绑定。<code>ChannelHandlerContext</code>允许<code>ChannelHandler</code>与其他的<code>ChannelHandler</code>实现进行交互。<code>ChannelHandlerContext</code>不会改变添加到其中的ChannelHandler，因此它是安全的</p>
<p>下图显示了<code>ChannelHandlerContext</code>、<code>ChannelHandler</code>、<code>ChannelPipeline</code>的关系： </p>
<center><img src="http://img.cuzz.site/20200915150214.png" /></center>

<p>最后我们看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的双向链表链表维护的是 <code>ChannelHandlerContext</code> 对象，而<code>ChannelHandlerContext</code> 包装了 <code>ChannelHandler</code></p>
<p>我们回到 <code>addLast</code> 方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>进入 <code>ChannelInitializer</code> 类中，我们看 <code>#initChannel</code> 方法，说这个方法当 <code>Channel</code> 注册时会被调用，一旦掉用完就会被移除 <code>ChannelPipeline</code>，这是因为只需要把里面封装的 Handler 添加到 <code>ChannelPipeline</code>，因为他本身就不一个 <code>Handler</code></p>
<blockquote>
<p>io.netty.channel.ChannelInitializer<br>protected abstract void initChannel(C ch)</p>
<p>This method will be called once the Channel was registered. After the method returns this instance will be removed from the ChannelPipeline of the Channel.</p>
</blockquote>
<p>下面是移除代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">            <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">        <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        initMap.remove(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChannelHandlerContext-attr-Channel-attr"><a href="#ChannelHandlerContext-attr-Channel-attr" class="headerlink" title="ChannelHandlerContext.attr(..) == Channel.attr(..)"></a>ChannelHandlerContext.attr(..) == Channel.attr(..)</h3><p><a target="_blank" rel="noopener" href="https://netty.io/wiki/new-and-noteworthy-in-4.1.html">https://netty.io/wiki/new-and-noteworthy-in-4.1.html</a></p>
<blockquote>
<p>Both <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a> and <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/ChannelHandlerContext.html"><code>ChannelHandlerContext</code></a> implement the interface <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/AttributeMap.html"><code>AttributeMap</code></a> to enable a user to attach one or more user-defined attributes to them. What sometimes made a user confused was that a <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a> and a <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/ChannelHandlerContext.html"><code>ChannelHandlerContext</code></a> had its own storage for the user-defined attributes. For example, even if you put an attribute ‘KEY_X’ via <code>Channel.attr(KEY_X).set(valueX)</code>, you will never find it via <code>ChannelHandlerContext.attr(KEY_X).get()</code> and vice versa. This behavior is not only confusing but also is waste of memory.</p>
<p>To address this issue, we decided to keep only one map per <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a> internally. <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/AttributeMap.html"><code>AttributeMap</code></a> always uses <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/AttributeKey.html"><code>AttributeKey</code></a> as its key. <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/AttributeKey.html"><code>AttributeKey</code></a> ensures uniqueness between each key, and thus there’s no point of having more than one attribute map per <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/Channel.html"><code>Channel</code></a>. As long as a user defines its own <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/util/AttributeKey.html"><code>AttributeKey</code></a> as a private static final field of his or her <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/channel/ChannelHandler.html"><code>ChannelHandler</code></a>, there will be no risk of duplicate keys.</p>
</blockquote>
<p><strong>注意：现在这两个关联的是一个Map</strong></p>
<h3 id="callHandlerCallbackLater"><a href="#callHandlerCallbackLater" class="headerlink" title="callHandlerCallbackLater"></a>callHandlerCallbackLater</h3><center><img src="http://img.cuzz.site/20200915150240.png" /></center>

<p>我们回到 <code>#addLast</code> 方法上，这个时候是还没有注册的，进入这个 <code>#callHandlerCallbackLater</code> 方法，把稍后调用 Handler 回调，封装成一个 task </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="keyword">boolean</span> added)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">    PendingHandlerCallback task = added ? <span class="keyword">new</span> PendingHandlerAddedTask(ctx) : <span class="keyword">new</span> PendingHandlerRemovedTask(ctx);</span><br><span class="line">    PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pendingHandlerCallbackHead = task;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find the tail of the linked-list.</span></span><br><span class="line">        <span class="keyword">while</span> (pending.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pending = pending.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pending.next = task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>我们回到io.netty.bootstrap.AbstractBootstrap#initAndRegister</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前面的初始化初始化已经有一点的了解，现在我来看注册，这里有<code>#config</code>，<code>#group</code> 和 <code>#register</code> 这三个方法，我们一个一个分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure>

<h3 id="config-方法"><a href="#config-方法" class="headerlink" title="config 方法"></a>config 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the &#123;<span class="doctag">@link</span> AbstractBootstrapConfig&#125; object that can be used to obtain the current config</span></span><br><span class="line"><span class="comment"> * of the bootstrap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractBootstrapConfig&lt;B, C&gt; <span class="title">config</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回了一个 <code>ServerbootstrapConfig</code> 对象</p>
<h3 id="group-方法"><a href="#group-方法" class="headerlink" title="group 方法"></a>group 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the configured &#123;<span class="doctag">@link</span> EventLoopGroup&#125; or &#123;<span class="doctag">@code</span> null&#125; if non is configured yet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> EventLoopGroup <span class="title">group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bootstrap.group();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个 <code>NioEventLoopGroup</code> 对象，这个时候返回的是一个调用的是他的父类<code>MultithreadEventLoopGroup</code>的 </p>
<h3 id="register-方法"><a href="#register-方法" class="headerlink" title="register 方法"></a>register 方法</h3><p>io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)</p>
<p>最终会调用 io.netty.channel.SingleThreadEventLoop#register(io.netty.channel.Channel) 的注册方法</p>
<p>我们来看看这个类</p>
<p>io.netty.channel.SingleThreadEventLoop</p>
<blockquote>
<p>io.netty.channel<br>public abstract class SingleThreadEventLoop<br>extends SingleThreadEventExecutor<br>implements EventLoop<br>Abstract base class for EventLoops that execute all its submitted tasks in a single thread.</p>
</blockquote>
<p>io.netty.channel.AbstractChannel.AbstractUnsafe#register</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">// 如果是当前线程就让它执行</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    <span class="comment">// 如果不是的话就放到线程池中注册</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先理解一下线程 Netty 中的线程模型</p>
<ul>
<li>一个 <code>EventLoopGroup</code> 当中会包含多个 <code>EventLoop</code></li>
<li>一个 <code>EventLoop</code> 在它的整个生命周期当中都只会与唯一一个 Thread 进行绑定</li>
<li>所有 <code>EventLoop</code> 所处理的各种 I/O 事件都是将在他所关联的那个 <code>Thread</code> 上进行处理</li>
<li>一个 <code>Channel</code> 在它的整个生命周期中只会注册在一个 <code>EventLoop</code> 上</li>
<li>一个 <code>EventLoop</code> 在运行过程中，会被分配给一或者多个 <code>Channel</code></li>
</ul>
<p><strong>重要结论：</strong></p>
<ol>
<li>在Netty 中 Channel 的实现是线程安全的，基于此，我们可以存储一个 Channel 的引用，并且在需要向远程端点发送数据时，通过这个引用来调用 Channel 相应的方法，即便是当时有很多线程都在使用它也不会出现多线程的问题，而且消息一点会按照这个顺序发送出去</li>
<li>我们在业务开发中，不要将执行耗时的任务放入到 EventLoop 的执行队列中，因为它会堵塞该线程的所有Channel 上的其它执行任务，如果我们需要进行阻塞调用或则是耗时操作，那么我们需要使用一个专门的EventExectutor(业务线程池)</li>
</ol>
<p><strong>通常会有两种实现方式：</strong></p>
<ol>
<li>在 ChannelHandler 的回调方法中，使用自己定义的业务线程池，这样就可以实现异步调用</li>
<li>借助于 Netty 提供的向 ChannelPipeline 添加ChannelHandler是调用的addLast方法来传递 EventExecutorGroup</li>
</ol>
<p>说明：如果addLast(handler)的方法是由I/O线程所执行的，如果addLast(eventExectutorGroup, handler)的方法，那么就是由参数中的group的线程组来执行</p>
<p>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></span><br><span class="line">        <span class="comment">// call was outside of the eventLoop</span></span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();  <span class="comment">// 这个方法</span></span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line">        <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></span><br><span class="line">                <span class="comment">// again so that we process inbound data.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>io.netty.channel.nio.AbstractNioChannel#doRegister</p>
<p>看到 <strong>doXxx</strong> 开头的方法就知道是认真工作的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与我们前面写的 NIO 逻辑是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">false</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerinitializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8899</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到我们编写的 Server 中，需要绑定，之后需要调用 <code>#sync</code> 表示这个方法需要同步，要不然还没绑定完成就返回了 <code>ChannelFuture</code> ，里面的结果或者状态是还没有完成的，加了 <code>#sync</code> 就能保证完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = bootstrap.bind(<span class="number">8899</span>).sync();</span><br></pre></td></tr></table></figure>

<p>在我们正常开发是流程就会停在下面，就卡住了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channelFuture.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>

<p>当我们调用关闭就会到 finally 中，会执行优雅关闭</p>
<p>到此我们启动过程基本分析完了</p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/01/19/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Netty 源码分析（四）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/01/15/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><span class="level-item">Netty 源码分析（二）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://unpkg.com/gitalk@1.6.2/dist/gitalk.css"><script src="https://unpkg.com/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "3ce384fc441d8189c29d3467948dbdb1",
            repo: "cuzz1.github.io",
            owner: "cuzz1",
            clientID: "e829281603f9115c572d",
            clientSecret: "246dae10dfb1b363805ab98902dc93539c355bb3",
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#addLast-方法"><span class="mr-2">1</span><span>addLast 方法</span></a><ul class="menu-list"><li><a class="is-flex" href="#ChannelHandlerContext"><span class="mr-2">1.1</span><span>ChannelHandlerContext</span></a></li><li><a class="is-flex" href="#ChannelHandlerContext-attr-Channel-attr"><span class="mr-2">1.2</span><span>ChannelHandlerContext.attr(..) == Channel.attr(..)</span></a></li><li><a class="is-flex" href="#callHandlerCallbackLater"><span class="mr-2">1.3</span><span>callHandlerCallbackLater</span></a></li></ul></li><li><a class="is-flex" href="#注册"><span class="mr-2">2</span><span>注册</span></a><ul class="menu-list"><li><a class="is-flex" href="#config-方法"><span class="mr-2">2.1</span><span>config 方法</span></a></li><li><a class="is-flex" href="#group-方法"><span class="mr-2">2.2</span><span>group 方法</span></a></li><li><a class="is-flex" href="#register-方法"><span class="mr-2">2.3</span><span>register 方法</span></a></li></ul></li><li><a class="is-flex" href="#sync"><span class="mr-2">3</span><span>sync</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2022 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://unpkg.com/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://unpkg.com/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://unpkg.com/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://unpkg.com/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>