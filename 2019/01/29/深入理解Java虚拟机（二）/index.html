<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>深入理解Java虚拟机（二） - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="深入理解Java虚拟机（二）"><meta property="og:url" content="http://blog.cuzz.site/2019/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://picsum.photos/548/304"><meta property="article:published_time" content="2019-01-29T15:59:59.000Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="JVM"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://picsum.photos/548/304"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2019/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"},"headline":"cuzz's blog","image":[],"datePublished":"2019-01-29T15:59:59.000Z","author":{"@type":"Person","name":"John Doe"},"description":"ClassLoader文档：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;7&#x2F;docs&#x2F;api&#x2F;java&#x2F;lang&#x2F;ClassLoader.html"}</script><link rel="canonical" href="http://blog.cuzz.site/2019/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/likes">Likes</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://picsum.photos/548/304" alt="深入理解Java虚拟机（二）"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-29T15:59:59.000Z" title="2019-01-29T15:59:59.000Z">2019-01-29</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解Java虚拟机</a></span><span class="level-item">an hour read (About 8498 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">深入理解Java虚拟机（二）</h1><div class="content"><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html">https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html</a></p>
<a id="more"></a>

<blockquote>
<p> public abstract class ClassLoader extends Object</p>
<p> A class loader is an object that is responsible for loading classes. The class <code>ClassLoader</code> is an abstract class. Given the <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#name">binary name</a> of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system. </p>
<p> Every <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html"><code>Class</code></a> object contains a <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getClassLoader()"><code>reference</code></a> to the <code>ClassLoader</code> that defined it.</p>
<p> <code>Class</code> objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getClassLoader()"><code>Class.getClassLoader()</code></a> is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p>
<p> Applications implement subclasses of <code>ClassLoader</code> in order to extend the manner in which the Java virtual machine dynamically loads classes.</p>
<p> Class loaders may typically be used by security managers to indicate security domains.</p>
<p> The <code>ClassLoader</code> class uses a delegation model to search for classes and resources. Each instance of <code>ClassLoader</code> has an associated parent class loader. When requested to find a class or resource, a <code>ClassLoader</code> instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a <code>ClassLoader</code> instance.</p>
<p> Class loaders that support concurrent loading of classes are known as <em>parallel capable</em> class loaders and are required to register themselves at their class initialization time by invoking the <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#registerAsParallelCapable()"><code>ClassLoader.registerAsParallelCapable</code></a> method. Note that the <code>ClassLoader</code> class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable.<br> In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#loadClass(java.lang.String)"><code>loadClass</code></a> methods).</p>
<p> Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the <code>CLASSPATH</code> environment variable.</p>
<p> However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#defineClass(java.lang.String,%20byte[],%20int,%20int)"><code>defineClass</code></a> converts an array of bytes into an instance of class <code>Class</code>. Instances of this newly defined class can be created using <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#newInstance()"><code>Class.newInstance</code></a>.</p>
<p> The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#loadClass(java.lang.String)"><code>loadClass</code></a> method of the class loader that originally created the class.</p>
<p> For example, an application could create a network class loader to download class files from a server. Sample code might look like:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLoader loader &#x3D; new NetworkClassLoader(host, port);</span><br><span class="line">Object main &#x3D; loader.loadClass(&quot;Main&quot;, true).newInstance();</span><br><span class="line">     . . .</span><br></pre></td></tr></table></figure>

<p> The network class loader subclass must define the methods <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#findClass(java.lang.String)"><code>findClass</code></a> and <code>loadClassData</code> to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#defineClass(byte[],%20int,%20int)"><code>defineClass</code></a> to create a class instance. A sample implementation is:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">    String host;</span><br><span class="line">    int port;</span><br><span class="line"> </span><br><span class="line">   public Class findClass(String name) &#123;</span><br><span class="line">        byte[] b &#x3D; loadClassData(name);</span><br><span class="line">        return defineClass(name, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        &#x2F;&#x2F; load the class data from the connection</span><br><span class="line">         . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>Binary names</strong></p>
<p> Any class name provided as a <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html"><code>String</code></a> parameter to methods in <code>ClassLoader</code> must be a binary name as defined by The Java™ Language Specification.</p>
<p> Examples of valid class names include:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;java.lang.String&quot; &#x2F;&#x2F; 一个类</span><br><span class="line">&quot;javax.swing.JSpinner$DefaultEditor&quot; &#x2F;&#x2F; 一个内部类</span><br><span class="line">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot; &#x2F;&#x2F; 内部类的匿名类</span><br><span class="line">&quot;java.net.URLClassLoader$3$1&quot; &#x2F;&#x2F; 匿名类的匿名类</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们知道类的加载是双亲委派机制，我们先来看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest15</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = MyTest15.class.getClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        ClassLoader loader1 = loader.getParent();</span><br><span class="line">        System.out.println(loader1);</span><br><span class="line">        ClassLoader loader2 = loader1.getParent();</span><br><span class="line">        System.out.println(loader2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@16d3586</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>当为根加载器时，返回null</p>
<p>看了文档，写一个自定义 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/28 12:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 将系统类加载当做该类加载器的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent); <span class="comment">// 显示指定该类加载的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data,<span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.classLoaderName = <span class="keyword">this</span>.classLoaderName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name, <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;myLoader&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MyTest01&quot;</span>);</span><br><span class="line">        Object o = clazz.newInstance(); <span class="comment">// 获取实例对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类加载器：&quot;</span> + clazz.getClassLoader());</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类加载器：sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">com.cuzz.jvm.classloader.MyTest01@16d3586</span><br></pre></td></tr></table></figure>

<p>我们编写的类加载器不起作用，因为双亲委派机制，当我们尝试使用自己编写的类加载器去加载时，它会委派自己的双亲去加载，刚好系统类加载器（应用类加载器）就能加载，所以不会使用我们自己编写的类加载器，而使用系统类加载器</p>
<p>如果我们把路径换一下，把项目路径下 classes 中的 MyTest01.class 文件移动在别的地方，让系统类加载器找不到，然后它就会调用我们自己编写的类加载器加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 将系统类加载当做该类加载器的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent); <span class="comment">// 显示指定该类加载的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data,<span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.path + name + <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;myLoader&quot;</span>);</span><br><span class="line">        <span class="comment">// Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.cuzz.jvm.classloader.MyTest01&quot;);</span></span><br><span class="line">        String path = <span class="string">&quot;C:/Users/my/Desktop/&quot;</span>;</span><br><span class="line">        myClassLoader.setPath(path);</span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MyTest01&quot;</span>);</span><br><span class="line">        Object o = clazz.newInstance(); <span class="comment">// 获取实例对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类加载器：&quot;</span> + clazz.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;父类加载器：&quot;</span> + myClassLoader.getParent());</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类加载器：com.cuzz.jvm.classloader.MyClassLoader@16d3586</span><br><span class="line">父类加载器：sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">com.cuzz.jvm.classloader.MyTest01@a14482</span><br></pre></td></tr></table></figure>



<h3 id="defineClas"><a href="#defineClas" class="headerlink" title="defineClas"></a>defineClas</h3><p>java.lang.ClassLoader#defineClass(java.lang.String, byte[], int, int)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len) <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过一个字节数组返回一个 Class 的实例</p>
<h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h3><p>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</p>
<p>文档：</p>
<blockquote>
<p>java.lang.ClassLoader<br>protected Class&lt;?&gt; loadClass(String name,<br>                             boolean resolve)<br>                     throws ClassNotFoundException<br>Loads the class with the specified binary name. The default implementation of this method searches for classes in the following order:</p>
<ol>
<li>Invoke findLoadedClass(String) to check if the class has already been loaded.</li>
<li>Invoke the loadClass method on the parent class loader. If the parent is null the class loader built-in to the virtual machine is used, instead.</li>
<li>Invoke the findClass(String) method to find the class.</li>
</ol>
<p>If the class was found using the above steps, and the resolve flag is true, this method will then invoke the resolveClass(Class) method on the resulting Class object.<br>Subclasses of ClassLoader are encouraged to override findClass(String), rather than this method.<br>Unless overridden, this method synchronizes on the result of getClassLoadingLock method during the entire class loading process.<br>Parameters:</p>
<ul>
<li>name - The binary name of the class</li>
<li>resolve - If true then resolve the class</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name); <span class="comment">// 我们只需要重写这个方法就可以</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>每一个类加载器斗鱼自己的命名空间，命名空间由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类，在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;myLoader&quot;</span>);</span><br><span class="line">    MyClassLoader myClassLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;myLoader1&quot;</span>);</span><br><span class="line">    String path = <span class="string">&quot;C:/Users/my/Desktop/&quot;</span>;</span><br><span class="line">    myClassLoader.setPath(path);</span><br><span class="line">    myClassLoader1.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MyTest01&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; clazz1 = myClassLoader1.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MyTest01&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;clazz: &quot;</span> + clazz.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;clazz1: &quot;</span> + clazz1.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clazz: 24324022</span><br><span class="line">clazz1: 21685669</span><br></pre></td></tr></table></figure>

<p>说明类被加载了两次，这就是由不同的命名空间导致的</p>
<p>如果我们给 myClassLoader1 添加一个父加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;myLoader&quot;</span>);</span><br><span class="line">    <span class="comment">// 把 myClassLoader 当做父加载器</span></span><br><span class="line">    MyClassLoader myClassLoader1 = <span class="keyword">new</span> MyClassLoader(myClassLoader,<span class="string">&quot;myLoader1&quot;</span>);</span><br><span class="line">    String path = <span class="string">&quot;C:/Users/my/Desktop/&quot;</span>;</span><br><span class="line">    myClassLoader.setPath(path);</span><br><span class="line">    myClassLoader1.setPath(path);</span><br><span class="line">    Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MyTest01&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; clazz1 = myClassLoader1.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MyTest01&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;clazz: &quot;</span> + clazz.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;clazz1: &quot;</span> + clazz1.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clazz: 10568834</span><br><span class="line">clazz1: 10568834</span><br></pre></td></tr></table></figure>

<p>由于父加载器已经加载过了，所以就不会加载了</p>
<h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。前面已经介绍过，Java 虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。Java 虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载类的 Class 对象，因此这些 Class 对象始终是可触及的</p>
<p>而由用户自定义的类加载器所加载的类是可以被卸载的</p>
<h3 id="类加载器命名空间深度解析"><a href="#类加载器命名空间深度解析" class="headerlink" title="类加载器命名空间深度解析"></a>类加载器命名空间深度解析</h3><p>通过一个例子来分析</p>
<p>MyCat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyCat is loaded by: &quot;</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MySample</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MySample is loaded by:&quot;</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyClassLoader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 将系统类加载当做该类加载器的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent); <span class="comment">// 显示指定该类加载的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data,<span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.path + name + <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;myLoader&quot;</span>);</span><br><span class="line">        String path = <span class="string">&quot;C:/Users/my/Desktop/&quot;</span>;</span><br><span class="line">        myClassLoader.setPath(path);</span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.MySample&quot;</span>);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@dad5dc</span><br></pre></td></tr></table></figure>

<p>我们知道我们自己写的 ClassLoader 与委托父类加载器去加载，所以是系统加载器加载的</p>
<p>现在我们把项目下 classes 路径中的 MySample.class 和 MyCat.class 删除，并复制一份到桌面</p>
<p>则输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySample is loaded by: com.cuzz.jvm.classloader.MyClassLoader@16d3586</span><br><span class="line">MyCat is loaded by: com.cuzz.jvm.classloader.MyClassLoader@16d3586</span><br></pre></td></tr></table></figure>

<p>由于委托父类加载器加载不到就用自己加载器加载</p>
<p>如果我们只把当前类路径下 MySample.class 这给文件删掉，保留 MyCat.class 文件，则输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySample is loaded by: com.cuzz.jvm.classloader.MyClassLoader@16d3586</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@dad5dc</span><br></pre></td></tr></table></figure>

<p>我们知道 MySample 是我们自定义类加载加载出来的，MyCat 是有系统类加载加载的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MySample &#123;</span><br><span class="line">    public MySample () &#123;</span><br><span class="line">        System.out.println(&quot;MySample is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line">        new MyCat ();</span><br><span class="line">        System.out.println(MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySample is loaded by: com.cuzz.jvm.classloader.MyClassLoader@16d3586</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">class com.cuzz.jvm.classloader.MyCat</span><br></pre></td></tr></table></figure>

<p>说明自定义类加载加载的类，可以访问系统类加载加载的类</p>
<p>如果我们在系统类加载的类中访问自定义类加载器加载的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyCat &#123;</span><br><span class="line">    public MyCat() &#123;</span><br><span class="line">        System.out.println(&quot;MyCat is loaded by: &quot; + this.getClass().getClassLoader());</span><br><span class="line">        System.out.println(MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySample is loaded by: com.cuzz.jvm.classloader.MyClassLoader@16d3586</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com&#x2F;cuzz&#x2F;jvm&#x2F;classloader&#x2F;MySample</span><br><span class="line">    at com.cuzz.jvm.classloader.MyCat.&lt;init&gt;(MyCat.java:6)</span><br><span class="line">    at com.cuzz.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)</span><br><span class="line">    at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">    at com.cuzz.jvm.classloader.MyClassLoader.main(MyClassLoader.java:68)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.cuzz.jvm.classloader.MySample</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    ... 8 more</span><br></pre></td></tr></table></figure>

<p>报错，说明系统加载器加载的类不能访问自定义加载器加载的类</p>
<p>说明当我现在加载 MySample 这个类时，使用的是我们自己定义的类加载器，然后初始实例化这个类时，需要初始化 MyCat 这个类，所以会先委托父加载器（系统加载器）去加载</p>
<p>但是如果我们把当前路径下的 MyCat.class 文件删掉，保留 MySample.class 文件，则报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; MySample is loaded by: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">java.lang.NoClassDefFoundError: com&#x2F;cuzz&#x2F;jvm&#x2F;classloader&#x2F;MyCat</span><br><span class="line">    at com.cuzz.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:422)</span><br><span class="line">    at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">    at com.cuzz.jvm.classloader.MyClassLoader.main(MyClassLoader.java:68)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.cuzz.jvm.classloader.MyCat</span><br><span class="line">    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    ... 7 more</span><br></pre></td></tr></table></figure>

<p>我要加载 MySample 先委托系统类加载加载，发现能加载到，然后再想加载 MyCat 这个类，此时它会调用系统加载器的父类去加载，发现加载不到，自己也不能加载，就报错了。</p>
<p>通过上面的例子，我们可以得出以下结论：</p>
<ol>
<li>子类加载器所加载的类能够访问到父加载器所加载的类</li>
<li>父类加载器所加载的类无法访问到子加载器所加载的类</li>
</ol>
<h2 id="类加载器的双亲委托模型的好处"><a href="#类加载器的双亲委托模型的好处" class="headerlink" title="类加载器的双亲委托模型的好处"></a>类加载器的双亲委托模型的好处</h2><p>可以确保 Java 核心库的类型安全：所有的 Java 应用都至少会引用 java.lang.Object 类，也就是说在运行期，java.lang.Object 这个类会被加载到 Java 虚拟机中；如果这个加载过程是由 Java 应用自己的类加载所完成的，那么很可能就会在 JVM 中存在多个版本的 java.lang.Object 了，而这些类之间还是不兼容的，相互不可见（正是命名空间发挥着作用）。可以确保 Java 核心类库所提供的类不会被自定义的类所取代。不同的类加载器可以为相同的名称（binary name）的类创建额外的命名空间。相同的名称的类可以并存在 Java 虚拟机中，只要用不同的类加载器来加载它们即可（可是是不同的类加载器，也可以是相同类加载器的不同实例）。不同的类加载器所加载的类之间是不兼容的，就相同于在 Java 虚拟机内部创建了一个又一个相互隔离的 Java 类空间，这类技术在很多框架中都得到了实际的应用。</p>
<p>内建于 JVM 中的启动类加载器会加载 java.lang.ClassLoader 以及其他的 Java 平台类，当 JVM 启动时，一块特殊的机器码会运行，它会加载扩展类加载器和系统类加载器，这块特殊的机器码叫做启动类加载器（Bootstrap），启动类加载器并不是 Java 类，而其它加载器则都是 Java 类，启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。启动类加载器还会负责加载 JRE 正常运行所需要的基本组件，这包括 java.util 与 java.lang 包中的类等等。</p>
<h2 id="Launcher-类源码分析"><a href="#Launcher-类源码分析" class="headerlink" title="Launcher 类源码分析"></a>Launcher 类源码分析</h2><p>前面我们分析类 ClassLoader，里面有一个静态方法 getSystemClassLoader，发现 ClassLoader 是 Launcher 中一个成员变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @CallerSensitive</span><br><span class="line"> public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">     initSystemClassLoader(); &#x2F;&#x2F; 初始化</span><br><span class="line">     if (scl &#x3D;&#x3D; null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br><span class="line">     SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">     if (sm !&#x3D; null) &#123;</span><br><span class="line">         checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">     &#125;</span><br><span class="line">     return scl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">     if (!sclSet) &#123;</span><br><span class="line">         if (scl !&#x3D; null)</span><br><span class="line">             throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">         &#x2F;&#x2F; 获取一个 Launcher 类</span><br><span class="line">         sun.misc.Launcher l &#x3D; sun.misc.Launcher.getLauncher();</span><br><span class="line">         if (l !&#x3D; null) &#123;</span><br><span class="line">             Throwable oops &#x3D; null;</span><br><span class="line">             &#x2F;&#x2F; scl 表示 SystemClassLoader</span><br><span class="line">             scl &#x3D; l.getClassLoader();</span><br><span class="line">             try &#123;</span><br><span class="line">                 scl &#x3D; AccessController.doPrivileged(</span><br><span class="line">                     new SystemClassLoaderAction(scl));</span><br><span class="line">             &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                 oops &#x3D; pae.getCause();</span><br><span class="line">                 if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                     oops &#x3D; oops.getCause();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">              ... </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在idea里边看到的 sun.misc.Launcher.getLauncher() 的实现是反编译工具给出的，oracle并没有给出源码，可以到网上查找相关代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =  System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the extension class loader</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">&quot;Could not create extension class loader&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">&quot;Could not create application class loader&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Also set the context class loader for the primordial thread.</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Finally, install a security manager if requested</span></span><br><span class="line">        String s = System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Returns the class loader used to launch the main application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Launcher 类初始化时，先初始化了个 ExtClassLoader，然后又初始化了个 AppClassLoader，然后把ExtClassLoader 作为 AppClassLoader的父 loader，ExtClassLoader 没有指定父类，即表明，父类是BootstrapClassLoader。把初始化 的AppClassLoader 作为全局变量保存起来，并设置到当前线程contextClassLoader，每个线程实例可以设置一个 contextClassLoader 。</p>
<p>先回到 initSystemClassLoader 方法中，有这一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scl = AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">&#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">    oops = pae.getCause();</span><br><span class="line">    <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">        oops = oops.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把系统加载传入到 doPrivileged 中的 SystemClassLoaderAction 中又返回了系统加载器，我们看看 SystemClassLoaderAction 这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoaderAction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">ClassLoader</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String cls = System.getProperty(<span class="string">&quot;java.system.class.loader&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="keyword">true</span>, parent)</span><br><span class="line">            .getDeclaredConstructor(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; parent &#125;);</span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        <span class="keyword">return</span> sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块逻辑的作用是看看是否设置了系统属性 java.system.class.loader，即自定义的系统类加载器，如果设置了那么实例化自定义的系统类加载器返回，替代之前获取的系统类加载器，如果没有设置直接返回默认的系统类加载器。 </p>
<h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h2><p>java.lang.Class#forName(java.lang.String, boolean, java.lang.ClassLoader)</p>
<p>文档：</p>
<blockquote>
<p>java.lang.Class<br>public static Class&lt;?&gt; forName(@NonNls String name,<br>                               boolean initialize,<br>                               ClassLoader loader)<br>                       throws ClassNotFoundException<br>Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.<br>If name denotes an array class, the component type of the array class is loaded but not initialized.<br>For example, in an instance method the expression:<br>Class.forName(“Foo”)<br>is equivalent to:<br>Class.forName(“Foo”, true, this.getClass().getClassLoader())<br>Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller.<br>If the loader is null, and a security manager is present, and the caller’s class loader is not null, then this method calls the security manager’s checkPermission method with a RuntimePermission(“getClassLoader”) permission to ensure it’s ok to access the bootstrap class loader.<br>Parameters:</p>
<ul>
<li>name - fully qualified name of the desired class</li>
<li>initialize - if true the class will be initialized. See Section 12.4 of The Java Language Specification.</li>
<li>loader - class loader from which the class must be loaded</li>
</ul>
</blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">        <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">        <span class="comment">// 获取调用 forName 方法的的那个类</span></span><br><span class="line">        caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) &#123;</span><br><span class="line">            ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">            <span class="keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123;</span><br><span class="line">                sm.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程上下文类加载器分析与实现"><a href="#线程上下文类加载器分析与实现" class="headerlink" title="线程上下文类加载器分析与实现"></a>线程上下文类加载器分析与实现</h2><p>接下来我们来分析一下线程上下文类加载的作用</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看一个程序来一下感性的认识：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">(Thread.currentThread()</span>.<span class="title">getContextClassLoader</span><span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println(Thread.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序的输出是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>解析：<br>第一行当前的线程是运行MyTest24 的线程，而MyTest24 是由系统类加载器加载，所以打印的是系统类加载器<br>第二行Thread类是java核心库的类，是由启动类加载器加载，所以不打印 null</p>
<p>**当前类加载器(Current ClassLoader) **</p>
<p>每个类都会使用自己的类加载器(即加载自身的类加载器) 来去加载其他类(指的是所依赖的类) ，如果ClassA引用了ClassY，那么ClassX的类加载器就会加载ClassY（前提是ClassY尚未被加载）</p>
<p><strong>线程上下文加载器（Context ClassLoader）</strong><br>线程上下文类加载器是从jdk1.2开始引入的，类Thread中的 getContextCLassLoader() 与setContextClassLoader(ClassLoader classloader) 分别用来获取和设置上下文类加载器，如果没有通过与setContextClassLoader(ClassLoader classloader)进行设置的话，线程将继承其父线程的上下文类加载器。 </p>
<p>Java应用运行时的初始线程的上下文加载器是系统类加载器，在线程中运行的代码可以通过该类加载器来加载类与资源。</p>
<p>我们在使用jdbc的时候，不同的数据库的驱动都是由每个厂商自己去实现，开发者在使用的时候，只需要把驱动jar包 ，放到当前path下边就可以了，这些驱动是由系统类加载器加载，而 java.sql 下边的一些Class在使用的时候不可避免的 ，要去使用厂商自定义的实现的逻辑，但是这些 java.sql 下的类的加载器是由启动类加载器完成的加载，由于父加载器(启动类加载器)加载的类无法访问子加载器（系统类加载器或者应用类加载器）加载的类，所以就无法在有些 java.sql 的类去访问具体的厂商实现，这个是双亲委托模型尴尬的一个局面。</p>
<p>线程上下文加载器的重要性： </p>
<p>SPI (Service Provider Interface) </p>
<p>父 ClassLoader 可以使用当前线程 Thread.currentThread().getContextClassLoader() 所指定的 classloader 加载的类。 这就改变了父 ClassLoader 不能使用子 ClassLoader 或是其他没有直接父子关系的 CLassLoader 加载的类的情况，即改变了双亲委托模型。</p>
<p>线程上下文加载器就是当前线程的 Current ClassLoader 在双亲委托模型下，类加载器由下至上的，即下层的类加载器会委托上层进行加载。但是对于 SPI 来说，有些接口是 java 核心库所提供的，而java核心库是由启动类加器来加载的，而这些接口的实现来自于不同的jar包（厂商提供），java 的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求，而通过给当前线程设置上下文加载器，就可以设置上下文类加载器来实现对于接口实现类的加载。</p>
<h3 id="线程上下文的一般使用模式"><a href="#线程上下文的一般使用模式" class="headerlink" title="线程上下文的一般使用模式"></a>线程上下文的一般使用模式</h3><p>线程上下文的一般使用模式分为3步，获取、使用和还原，下面是伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(targetClassLoader);</span><br><span class="line">    method();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 还原</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>method 里面调用了 Thread.currentThread().getContextClassLoader()，获取当前线程上下文类加载器做某些事情。如果一个类由类加载器 A 加载，那么这个类的依赖也是有相同的类加载器加载的（如果该依赖类之前没有加载过的话），ContextClassLoader 的作用就是为了破坏 Java 的类加载委托机制。</p>
<p>当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层类时，就必须要通过线程上下文类加载器来帮助高层的 ClassLoader 找到并加载该类。</p>
<h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>我们先引入驱动依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group &#39;com.cuzz.jvm&#39;</span><br><span class="line">version &#39;1.0&#39;</span><br><span class="line"></span><br><span class="line">apply plugin: &#39;java&#39;</span><br><span class="line"></span><br><span class="line">sourceCompatibility &#x3D; 1.8</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile (</span><br><span class="line">            &quot;mysql:mysql-connector-java:5.1.34&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/2/1 14:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; serviceLoader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = serviceLoader.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Driver driver =  iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;driver: &quot;</span>+driver.getClass() + <span class="string">&quot;loader: &quot;</span>+ driver.getClass().getClassLoader() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程上下文类加载器: &quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ServiceLoader的类加载器: &quot;</span>+ServiceLoader.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driverloader: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriverloader: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">当前线程上下文类加载器: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">ServiceLoader的类加载器: null</span><br></pre></td></tr></table></figure>

<p>我们可以看到 ServiceLoader 找到了 mysql 的两个驱动，这两个驱动都是由系统类加载器加载的，当前线程的上下文加载器默认也是系统类加载器，ServiceLoader是由启动类加载器加载，但是程序是怎样找到 mysql 的两个驱动的呢？我们没有在程序里边设置任何的属性或者路径之类的东西让程序能找到 mysql 的驱动，那么我们只能研究一下 ServiceLoader 的源码和文档看一下他们的原理：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class ServiceLoader&lt;S&gt;</span><br><span class="line">extends Object</span><br><span class="line">implements Iterable&lt;S&gt;</span><br></pre></td></tr></table></figure>

<p>A simple service-provider loading facility.<br>A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers can also be made available by adding them to the application’s class path or by some other platform-specific means.<br>For the purpose of loading, a service is represented by a single type, that is, a single interface or abstract class. (A concrete class can be used, but this is not recommended.) A provider of a given service contains one or more concrete classes that extend this service type with data and code specific to the provider. The provider class is typically not the entire provider itself but rather a proxy which contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand. The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such type is defined here. The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.<br>A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file’s name is the fully-qualified binary name of the service’s type. The file contains a list of fully-qualified binary names of concrete provider classes, one per line. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is ‘#’ (‘\u0023’, NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.<br>If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.<br>Providers are located and instantiated lazily, that is, on demand. A service loader maintains a cache of the providers that have been loaded so far. Each invocation of the iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order, and then lazily locates and instantiates any remaining providers, adding each one to the cache in turn. The cache can be cleared via the reload method.<br>Service loaders always execute in the security context of the caller. Trusted system code should typically invoke the methods in this class, and the methods of the iterators which they return, from within a privileged security context.<br>Instances of this class are not safe for use by multiple concurrent threads.<br>Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown.<br>Example Suppose we have a service type com.example.CodecSet which is intended to represent sets of encoder/decoder pairs for some protocol. In this case it is an abstract class with two abstract methods:<br>   public abstract Encoder getEncoder(String encodingName);<br>   public abstract Decoder getDecoder(String encodingName);<br>Each method returns an appropriate object or null if the provider does not support the given encoding. Typical providers support more than one encoding.<br>If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named<br>   META-INF/services/com.example.CodecSet<br>This file contains the single line:<br>   com.example.impl.StandardCodecs    # Standard codecs<br>The CodecSet class creates and saves a single service instance at initialization:`</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ServiceLoader&lt;CodecSet&gt; codecSetLoader = ServiceLoader.load(CodecSet.class);</span><br></pre></td></tr></table></figure>

<p>To locate an encoder for a given encoding name it defines a static factory method which iterates through the known and available providers, returning only when it has located a suitable encoder or has run out of providers.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Encoder <span class="title">getEncoder</span><span class="params">(String encodingName)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (CodecSet cp : codecSetLoader) </span><br><span class="line">         Encoder enc = cp.getEncoder(encodingName);</span><br><span class="line">         <span class="keyword">if</span> (enc != <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> enc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>A getDecoder method is defined similarly.<br>Usage Note If the class path of a class loader that is used for provider loading includes remote network URLs then those URLs will be dereferenced in the process of searching for provider-configuration files.<br>This activity is normal, although it may cause puzzling entries to be created in web-server logs. If a web server is not configured correctly, however, then this activity may cause the provider-loading algorithm to fail spuriously.<br>A web server should return an HTTP 404 (Not Found) response when a requested resource does not exist. Sometimes, however, web servers are erroneously configured to return an HTTP 200 (OK) response along with a helpful HTML error page in such cases. This will cause a ServiceConfigurationError to be thrown when this class attempts to parse the HTML page as a provider-configuration file. The best solution to this problem is to fix the misconfigured web server to return the correct response code (HTTP 404) along with the HTML error page.</p>
</blockquote>
<p>我们先看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The class or interface representing the service being loaded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The access control context taken when the ServiceLoader is created</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cached providers, in instantiation order</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The current lazy-lookup iterator</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类中有个常量 PREFIX ，根据文档我们可以知道这是一个目录，我们看看 mysql-connnector-java 中也有</p>
<center><img src="http://img.cuzz.site/20201229174018.png" width="100%"></center>

<p>其下的文件名字就是服务的名字，比如数据库驱动的服务是java.sql.Drive，我们在mysql的jar包下可以看到这个文件，文件里边的内容是具体的实现类的全限定名：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.mysql.jdbc.Driver</span><br><span class="line">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure>

<p>与前面打印出来的驱动是一样的</p>
<p>ServiceLoader 是由启动类加载器加载的，为什么 mysql 的驱动是由系统类加载器加载呢？</p>
<p>前面代码中 <code>ServiceLoader serviceLoader = ServiceLoader.load(Driver.class);</code>  这段代码是怎么起作用的呢，跟进源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前上下文类加载，并使用上下文类加载器去加载</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用一个构造方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然 ServiceLoader 是由启动类加载器加载，那么 ServiceLoader 里边的类都会用启动类加载器去加载，但是呢我们的 mysql 驱动不在启动类加载器加载的目录下边，我们的 mysql 驱动位于 classpath 下边，无法用启动类加载器加载，这个时候，我们可以看到 load 方法使用了线程上下文加载器，线程上下文加载器默认是系统类加载器</p>
<p>我们来看看这个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">       service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">       loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">       acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">       reload();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 调用reload() 方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 清空缓存  providers = new LinkedHashMap&lt;&gt;();</span></span><br><span class="line">       providers.clear(); </span><br><span class="line">       <span class="comment">// 懒加载</span></span><br><span class="line">       lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LazyIterator 类</p>
<p>java.util.ServiceLoader.LazyIterator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">    String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String fullName = PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service,</span><br><span class="line">                 <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                 x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hasNextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就把驱动加载出来了，则前面代码输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driverloader: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriverloader: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">当前线程上下文类加载器: sun.misc.Launcher$AppClassLoader@dad5dc</span><br><span class="line">ServiceLoader的类加载器: null</span><br></pre></td></tr></table></figure>

<p>如果我们把前面代码改一下，设置当前线程的上下文类加载器为扩展类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把当前线程设置为扩展类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(MyTest26.class.getClassLoader().getParent());</span><br><span class="line">        ServiceLoader&lt;Driver&gt; serviceLoader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = serviceLoader.iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Driver driver =  iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;driver: &quot;</span>+driver.getClass() + <span class="string">&quot;loader: &quot;</span>+ driver.getClass().getClassLoader() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程上下文类加载器: &quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ServiceLoader的类加载器: &quot;</span>+ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前线程上下文类加载器: sun.misc.Launcher$ExtClassLoader@a14482</span><br><span class="line">ServiceLoader的类加载器: null</span><br></pre></td></tr></table></figure>

<p>可以看到循环没有去执行，上下文类加载器是扩展类加载器没啥问题，因为系统类加载器的上级是扩展类加载器，但是为什么循环是空的呢？原因就是扩展类加载器无法加载 classpath下边的类，mysql 的 jar 包是放在 classpath下边的。</p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JVM/">JVM</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">深入理解Java虚拟机（三）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"><span class="level-item">深入理解Java虚拟机（一）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "a9c420dd7928b54d1054270b397d4d1a",
            repo: "cuzz1.github.io",
            owner: "cuzz1",
            clientID: "e829281603f9115c572d",
            clientSecret: "246dae10dfb1b363805ab98902dc93539c355bb3",
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#ClassLoader"><span class="mr-2">1</span><span>ClassLoader</span></a><ul class="menu-list"><li><a class="is-flex" href="#defineClas"><span class="mr-2">1.1</span><span>defineClas</span></a></li><li><a class="is-flex" href="#loadClass"><span class="mr-2">1.2</span><span>loadClass</span></a></li><li><a class="is-flex" href="#命名空间"><span class="mr-2">1.3</span><span>命名空间</span></a></li><li><a class="is-flex" href="#类的卸载"><span class="mr-2">1.4</span><span>类的卸载</span></a></li><li><a class="is-flex" href="#类加载器命名空间深度解析"><span class="mr-2">1.5</span><span>类加载器命名空间深度解析</span></a></li></ul></li><li><a class="is-flex" href="#类加载器的双亲委托模型的好处"><span class="mr-2">2</span><span>类加载器的双亲委托模型的好处</span></a></li><li><a class="is-flex" href="#Launcher-类源码分析"><span class="mr-2">3</span><span>Launcher 类源码分析</span></a></li><li><a class="is-flex" href="#Class-forName"><span class="mr-2">4</span><span>Class.forName()</span></a></li><li><a class="is-flex" href="#线程上下文类加载器分析与实现"><span class="mr-2">5</span><span>线程上下文类加载器分析与实现</span></a><ul class="menu-list"><li><a class="is-flex" href="#前言"><span class="mr-2">5.1</span><span>前言</span></a></li><li><a class="is-flex" href="#线程上下文的一般使用模式"><span class="mr-2">5.2</span><span>线程上下文的一般使用模式</span></a></li><li><a class="is-flex" href="#ServiceLoader"><span class="mr-2">5.3</span><span>ServiceLoader</span></a></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>