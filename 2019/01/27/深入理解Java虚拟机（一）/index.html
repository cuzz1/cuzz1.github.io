<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>深入理解Java虚拟机（一） - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="深入理解Java虚拟机（一）"><meta property="og:url" content="http://blog.cuzz.site/2019/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://picsum.photos/514/345"><meta property="article:published_time" content="2019-01-27T15:59:59.000Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="JVM"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://picsum.photos/514/345"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2019/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"},"headline":"cuzz's blog","image":[],"datePublished":"2019-01-27T15:59:59.000Z","author":{"@type":"Person","name":"John Doe"},"description":"类加载机制在 Java 代码中，类型（类，接口，枚举）的加载、连接（验证，准备，解析）与初始化过程都是在程序运行期间完成的，提供了更大的灵活性，增加了更多的可能性"}</script><link rel="canonical" href="http://blog.cuzz.site/2019/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/likes">Likes</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://picsum.photos/514/345" alt="深入理解Java虚拟机（一）"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-27T15:59:59.000Z" title="2019-01-27T15:59:59.000Z">2019-01-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解Java虚拟机</a></span><span class="level-item">22 minutes read (About 3262 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">深入理解Java虚拟机（一）</h1><div class="content"><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>在 Java 代码中，类型（类，接口，枚举）的加载、连接（验证，准备，解析）与初始化过程都是在<strong>程序运行期间完成的</strong>，提供了更大的灵活性，增加了更多的可能性</p>
<a id="more"></a>

<h3 id="类加载器深入剖析"><a href="#类加载器深入剖析" class="headerlink" title="类加载器深入剖析"></a>类加载器深入剖析</h3><p>Java 虚拟机与程序的生命周期</p>
<p>在如下几种情况下，Java 虚拟机将结束生命周期</p>
<ul>
<li>执行了 <code>System.exit()</code> 方法</li>
<li>程序正常执行结束</li>
<li>程序在执行的过程中遇到了异常或则错误而异常终止</li>
<li>由于操作系统出现了错误，导致 Java 虚拟机进程结束</li>
</ul>
<h3 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h3><center><img src="http://img.cuzz.site/20201229173404.jpg" width="100%"></center> 

<ul>
<li>加载：查找并加载类的二进制数据</li>
<li>连接<ul>
<li>验证：确保被加载的类的正确性</li>
<li>准备：为类的<strong>静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong></li>
<li>解析：把类中的符号引用转化为直接引用</li>
</ul>
</li>
<li>初始化：为静态变量赋予正确的初始值</li>
<li>使用（类的实例化）：<ul>
<li>为新的对象分配内存</li>
<li>为实例变量赋默认值</li>
<li>为实例变量赋予正确的初始值</li>
<li>Java 编译器为它编译的每一个类都至少生成一个实例初始化方法，在 Java 的 class 文件中，这这实例初始方法被称为 <code>&lt;init&gt;</code> ，对源代码中的每一个类的构造方法，java 编译器都产生一个 <code>&lt;init&gt;</code> 方法</li>
</ul>
</li>
</ul>
<p>Java 程序对类的使用方式可以分为两种：</p>
<ul>
<li>主动使用 <ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或则对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 <code>Class.forName(&quot;com.cuzz.Test&quot;)</code>）</li>
<li>初始化一个子类</li>
<li>Java 虚拟机启动时被标明为启动类的类</li>
</ul>
</li>
<li>被动使用</li>
</ul>
<p>所有的 Java 虚拟机实现必须在每个类或接口被 Java 程序<strong>首次主动使用</strong>时才初始化他们</p>
<p>我们来看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child1.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent1 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child1 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent1 static block</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p><strong>对于静态代码块，只有定义该字段的类才会被初始化</strong>，这个 <code>Child1.str</code> 是子类调用父类的静态字段，所以子类不会被初始化，父类才会被初始化，这是对 <code>Parent1</code> 的主动使用，对于这个例子只是用了 <code>Child1</code> 的名字，并没有主动使用 <code>Child1</code> 这个类</p>
<p>我们在来看看有没有被加载到虚拟机中，在 VM options : <code>-XX:+TraceClassLoading</code> 在运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded com.cuzz.jvm.classloader.Parent1 from file:&#x2F;E:&#x2F;project&#x2F;learn-demo&#x2F;demo-10-jvm-lecture&#x2F;out&#x2F;production&#x2F;classes&#x2F;]</span><br><span class="line">[Loaded com.cuzz.jvm.classloader.Child1 from file:&#x2F;E:&#x2F;project&#x2F;learn-demo&#x2F;demo-10-jvm-lecture&#x2F;out&#x2F;production&#x2F;classes&#x2F;]</span><br><span class="line">Parent1 static block</span><br><span class="line">hello world</span><br><span class="line">[Loaded java.lang.Shutdown from E:\deployer\jdk8\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from E:\deployer\jdk8\jre\lib\rt.jar]</span><br></pre></td></tr></table></figure>

<p>发现这两个类已经被加载到虚拟中</p>
<p>再看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child1.str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent1 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">Parent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str2 = <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child1 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent1 static block</span><br><span class="line">Child1 static block</span><br><span class="line">welcome</span><br></pre></td></tr></table></figure>

<p>当我们初始一个子类，我们会先初始化父类，所以会线输出父类的静态代码块</p>
<p>如果我们加上 final 变为常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/25 19:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent2 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>常量在<strong>编译阶段</strong>会存入到<strong>调用这个常量的方法所在的类的常量池中</strong>（也就是说会存入MyTest02这个类中），本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化</p>
<p>注意：这里指的是将常量存放到了 MyTest02 的常量池中，之后 MyTest02 与 Parent2 就没有任何关系了，甚至我们可以将 Parent 的 class 文件删除</p>
<p>我们进入 classes 目录下使用：<code>javap -c com.cuzz.jvm.classloader.MyTest02</code> 命令反编译一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;MyTest02.java&quot;</span><br><span class="line">public class com.cuzz.jvm.classloader.MyTest02 &#123;</span><br><span class="line">  public com.cuzz.jvm.classloader.MyTest02();&#x2F;&#x2F; (1)</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       3: ldc           #4  (2)             &#x2F;&#x2F; String hello world  (3)</span><br><span class="line">       5: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>是构造方法</li>
<li>ldc 助记符表示将 int，float 或 String 类型的值从常量池中推送至栈顶</li>
<li>可以看出<code>Parent2.str</code> 已经转化为 <code>hello world</code></li>
</ol>
<p>注：当 int 取值-1<del>5采用iconst指令，取值-128</del>127采用 bipush 指令，取值-32768<del>32767采用 sipush 指令，取值-2147483648</del>2147483647采用 ldc 指令</p>
<p>我们在看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent3 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parent3 static block</span><br><span class="line">bee2f54d-8960-46d0-b5d7-02666fcf4a14</span><br></pre></td></tr></table></figure>

<p>相比于上一个例子，我们发现输出了静态代码块，说明 Parent3 这个类被初始化了，当一个常量的值并非编译期间可以确定的，那么器值就不会放到调用类的常量池中，这是在程序运行时，会导致主动使用这个常量所在的类，会导致这给类初始化</p>
<p>再看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent4[] parent4s = <span class="keyword">new</span> Parent4[<span class="number">1</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        System.out.println(parent4s.getClass());</span><br><span class="line">        System.out.println(parent4s.getClass().getSuperclass());</span><br><span class="line">        System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">        System.out.println(ints.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent4 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------</span><br><span class="line">class [Lcom.cuzz.jvm.classloader.Parent4;</span><br><span class="line">class java.lang.Object</span><br><span class="line">---------</span><br><span class="line">class [I</span><br><span class="line">class java.lang.Object</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>对于数组实例来说，其类型是由 JVM 在运行期动态生成的，表示为 <code> [Lcom.cuzz.jvm.classloader.Parent4</code> 这种形式，动态生成的类型，其父类型就是 Object</p>
<p>对于数组来说，JavaDoc 经常将构成的数组元素称为 Component，实际上就是将数组降低一个维度的类型</p>
<p>我们使用 <code>javap -c com.cuzz.jvm.classloader.MyTest04</code> 进行反编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class com.cuzz.jvm.classloader.MyTest04 &#123;</span><br><span class="line">  public com.cuzz.jvm.classloader.MyTest04();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: anewarray     #2                  &#x2F;&#x2F; class com&#x2F;cuzz&#x2F;jvm&#x2F;classloader&#x2F;Parent4</span><br><span class="line">       4: astore_1</span><br><span class="line">       5: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       8: ldc           #4                  &#x2F;&#x2F; String ---------</span><br><span class="line">      10: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">      13: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.getClass:()Ljava&#x2F;lang&#x2F;Class;</span><br><span class="line">      20: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">      23: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      26: aload_1</span><br><span class="line">      27: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.getClass:()Ljava&#x2F;lang&#x2F;Class;</span><br><span class="line">      30: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Class.getSuperclass:()Ljava&#x2F;lang&#x2F;Class;</span><br><span class="line">      33: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">      36: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      39: ldc           #4                  &#x2F;&#x2F; String ---------</span><br><span class="line">      41: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">      44: iconst_1</span><br><span class="line">      45: newarray       int</span><br><span class="line">      47: astore_2</span><br><span class="line">      48: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      51: aload_2</span><br><span class="line">      52: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.getClass:()Ljava&#x2F;lang&#x2F;Class;</span><br><span class="line">      55: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">      58: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">      61: aload_2</span><br><span class="line">      62: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.getClass:()Ljava&#x2F;lang&#x2F;Class;</span><br><span class="line">      65: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Class.getSuperclass:()Ljava&#x2F;lang&#x2F;Class;</span><br><span class="line">      68: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">      71: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面有两个助记符</p>
<ul>
<li>anewarray ：表示创建一个引用类型的（如类、接口、数组）数组，并将其值压入栈顶</li>
<li>newarray：表示创建一个指定的原始类型（如int、float、char等）数组，并将其引用值压入栈顶</li>
</ul>
<p>下一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child5.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Parent5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Child5</span> <span class="keyword">extends</span> <span class="title">Parent5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后我们把 Parent5.class 文件删掉，还能打印出 55，说明当一个接口在初始化时，并不要求其父接口都完成初始化，如果我们把 Child5.class 文件也删掉，也能打印出 55，<strong>原来接口中的修饰符默认为 <code>public static final</code>  说明接口中的值是一个常量</strong>，不需要加载到 JVM 中，也就没有初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child5.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Parent5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Parent5 static block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child5</span> <span class="keyword">implements</span> <span class="title">Parent5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时也也是输出 55 ，也没有初始化 Child5 接口 Parent5 </p>
<p>下一例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.newSingleton();</span><br><span class="line">        System.out.println(Singleton.counter1);</span><br><span class="line">        System.out.println(Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;   <span class="comment">// counter1 = 1</span></span><br><span class="line">        counter2++;   <span class="comment">// counter2 = 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;   <span class="comment">// 此时又把值赋值为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>为什么会这样呢，准备阶段 counter1 和 counter2 的初始值都是 0 ，初始化阶段从上往下赋值，后面 counter2 又赋值为 0</p>
<p>我们再来回顾一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest09</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyTest09 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child9.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent9</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent9 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child9</span> <span class="keyword">extends</span> <span class="title">Parent9</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child9 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyTest09 static block</span><br><span class="line">Parent9 static block</span><br><span class="line">Child9 static block</span><br><span class="line">99</span><br></pre></td></tr></table></figure>

<p>我们多输出点信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest09</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyTest09 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent9 parent9;     <span class="comment">// 不会初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        parent9 = <span class="keyword">new</span> Parent9();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.println(Parent9.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.println(Child9.j);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent9</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent9 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child9</span> <span class="keyword">extends</span> <span class="title">Parent9</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child9 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyTest09 static block</span><br><span class="line">-------------</span><br><span class="line">Parent9 static block</span><br><span class="line">-------------</span><br><span class="line">9</span><br><span class="line">-------------</span><br><span class="line">Child9 static block</span><br><span class="line">99</span><br></pre></td></tr></table></figure>

<p>在看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;com.cuzz.jvm.classloader.CL&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        clazz = Class.forName(<span class="string">&quot;com.cuzz.jvm.classloader.CL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CL static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------</span><br><span class="line">CL static block</span><br></pre></td></tr></table></figure>

<p>说明调用 ClassLoader 类的 loadClass 方法加载一个类，并不是对类的主动使用，不会导致类的初始化，而通过 Class.forName 方法是通过反射机制，会对类初始化</p>
<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类的加载是指将类的 <code>.class</code> 文件中的二进制数据读入到内存中，将其运行时数据区的方法区内，然后在内存中创建一个 <code>java.lang.Class</code> 对象（规范中并未说明Class对象位于哪里，HotSpot 虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构</p>
<p>加载 <code>.class</code> 文件的方式</p>
<ul>
<li>从本地系统中直接加载 <code>.class</code> 文件</li>
<li>通过网络下载的 <code>.class</code> 文件</li>
<li>从 zip，jar 等归档文件中加载 <code>.class</code> 文件</li>
<li>从专有数据库中提取 <code>.class</code> 文件</li>
<li>将 Java 源文件动态编译为 <code>.class</code> 文件</li>
</ul>
<h4 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h4><center><img src="http://img.cuzz.site/20201229173426.png" width="80%"></center>

<p>类的加载器分类：</p>
<ul>
<li>Java 虚拟机自带的加载器<ul>
<li>根加载器（Bootstrap）</li>
<li>拓展类加载器（Extension）</li>
<li>应用加载器（Application）</li>
</ul>
</li>
<li>用户自定义的类加载器<ul>
<li>java.lang.ClassLoader 的子类</li>
<li>用户定制类的加载方法</li>
</ul>
</li>
</ul>
<p>注意：类的加载并不需要等到某个类被<strong>首次主动使用</strong>时再加载它；JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载过程中遇到了 <code>.class</code> 文件缺失或存在错误，类加载器必须在<strong>程序首次主动使用</strong>该类才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<p>看一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz1 = Class.forName(<span class="string">&quot;com.cuzz.jvm.classloader.C&quot;</span>);</span><br><span class="line">        System.out.println(clazz1.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@dad5dc</span><br></pre></td></tr></table></figure>

<p>看看 getClassLoader 的文档</p>
<blockquote>
<p>Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader. This method will return null in such implementations if this class was loaded by the bootstrap class loader.</p>
</blockquote>
<p>说明输出 <code>null</code> 说明 <code>java.lang.String</code> 是根加载器加载的</p>
<h4 id="获取-ClassLoader-的途径"><a href="#获取-ClassLoader-的途径" class="headerlink" title="获取 ClassLoader 的途径"></a>获取 ClassLoader 的途径</h4><ul>
<li><p>获得当前类 ClassLoader </p>
<p>clazz.getClassLoader()</p>
</li>
<li><p>获得当前线程上下文的 ClassLoader</p>
<p>Thread.currentThread().getContextClassLoader()</p>
</li>
<li><p>获取系统的 ClassLoader</p>
<p>ClassLoader.getSystemClassLoader()</p>
</li>
<li><p>获取调用者的 ClassLoader</p>
<p>DriverManger.getCallerClassLoader()</p>
</li>
</ul>
<h3 id="类的验证"><a href="#类的验证" class="headerlink" title="类的验证"></a>类的验证</h3><p>类的验证的内容：</p>
<ul>
<li>类文件的结构检查</li>
<li>语义检查</li>
<li>字节码验证</li>
<li>二进制兼容性的验证</li>
</ul>
<h3 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h3><p>当 Java 虚拟机在初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
</ul>
<p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化</p>
<h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><p>非稳态选项使用说明:</p>
<ul>
<li><code>-XX:+&lt;option&gt;</code> 启用 option</li>
<li><code>-XX:-&lt;option&gt;</code> 不启用 option</li>
<li><code> -XX:&lt;option&gt;=&lt;number&gt;</code> 设定option的值为数字类型，可跟单位，例如 32k, 1024m, 2g </li>
<li><code> -XX:&lt;option&gt;=&lt;string&gt;</code> 设定option的值为字符串，例如-XX:HeapDumpPath=./dump.core </li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JVM/">JVM</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/01/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">深入理解Java虚拟机（二）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/01/22/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"><span class="level-item">Netty 源码分析（五）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "b43807422b565ab0ac4399e538fa7bd9",
            repo: "cuzz1.github.io",
            owner: "cuzz1",
            clientID: "e829281603f9115c572d",
            clientSecret: "246dae10dfb1b363805ab98902dc93539c355bb3",
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#类加载机制"><span class="mr-2">1</span><span>类加载机制</span></a><ul class="menu-list"><li><a class="is-flex" href="#类加载器深入剖析"><span class="mr-2">1.1</span><span>类加载器深入剖析</span></a></li><li><a class="is-flex" href="#类的加载、连接与初始化"><span class="mr-2">1.2</span><span>类的加载、连接与初始化</span></a></li><li><a class="is-flex" href="#类的加载"><span class="mr-2">1.3</span><span>类的加载</span></a><ul class="menu-list"><li><a class="is-flex" href="#类的加载器"><span class="mr-2">1.3.1</span><span>类的加载器</span></a></li><li><a class="is-flex" href="#获取-ClassLoader-的途径"><span class="mr-2">1.3.2</span><span>获取 ClassLoader 的途径</span></a></li></ul></li><li><a class="is-flex" href="#类的验证"><span class="mr-2">1.4</span><span>类的验证</span></a></li><li><a class="is-flex" href="#类的初始化时机"><span class="mr-2">1.5</span><span>类的初始化时机</span></a></li></ul></li><li><a class="is-flex" href="#JVM参数设置"><span class="mr-2">2</span><span>JVM参数设置</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>