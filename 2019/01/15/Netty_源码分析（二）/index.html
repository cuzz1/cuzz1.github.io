<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Netty 源码分析（二） - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="Netty 源码分析（二）"><meta property="og:url" content="http://blog.cuzz.site/2019/01/15/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://picsum.photos/516/330"><meta property="article:published_time" content="2019-01-15T14:24:12.000Z"><meta property="article:modified_time" content="2020-12-05T08:53:11.585Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="源码"><meta property="article:tag" content="NIO"><meta property="article:tag" content="Reactor"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://picsum.photos/516/330"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2019/01/15/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"},"headline":"cuzz's blog","image":[],"datePublished":"2019-01-15T14:24:12.000Z","dateModified":"2020-12-05T08:53:11.585Z","author":{"@type":"Person","name":"John Doe"},"description":"版本 4.1.15    官网：https:&#x2F;&#x2F;netty.io&#x2F;  Netty is an asynchronous event-driven network application framework  for rapid development of maintainable high performance protocol servers &amp; clients."}</script><link rel="canonical" href="http://blog.cuzz.site/2019/01/15/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://picsum.photos/516/330" alt="Netty 源码分析（二）"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-01-15T14:24:12.000Z" title="2019-01-15T14:24:12.000Z">2019-01-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-05T08:53:11.585Z" title="2020-12-05T08:53:11.585Z">2020-12-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Netty 源码分析（二）</h1><div class="content"><p>版本 4.1.15   </p>
<p>官网：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<blockquote>
<p>Netty is <em>an asynchronous event-driven network application framework</em>  for rapid development of maintainable high performance protocol servers &amp; clients. </p>
</blockquote>
<a id="more"></a>

<h2 id="先来看一个NIO网络编程"><a href="#先来看一个NIO网络编程" class="headerlink" title="先来看一个NIO网络编程"></a>先来看一个NIO网络编程</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/7 15:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 储存客户端连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SocketChannel&gt; clientMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                selectionKeys.forEach(selectionKey -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;      <span class="comment">// 可以读</span></span><br><span class="line">                            read(selector, selectionKey);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123; <span class="comment">// 可以写</span></span><br><span class="line">                            write(selector, selectionKey);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                selectionKeys.clear(); <span class="comment">// 别忘了清空</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Selector selector, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">int</span> read = client.read(byteBuffer);</span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            String receiveMessage = String.valueOf(charset.decode(byteBuffer).array());</span><br><span class="line">            System.out.println(client + <span class="string">&quot;: &quot;</span> + receiveMessage);</span><br><span class="line"></span><br><span class="line">            String key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, SocketChannel&gt; entry : clientMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == client) &#123;</span><br><span class="line">                    key = entry.getKey();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, SocketChannel&gt; entry : clientMap.entrySet()) &#123;</span><br><span class="line">                SocketChannel value = entry.getValue();</span><br><span class="line">                ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                writeBuffer.put((key + <span class="string">&quot; :&quot;</span> + receiveMessage).getBytes());</span><br><span class="line">                writeBuffer.flip();</span><br><span class="line">                value.write(writeBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Selector selector, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">        System.out.println(server);</span><br><span class="line">        SocketChannel client = server.accept();</span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        String key = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 保存客户端</span></span><br><span class="line">        clientMap.put(key, client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客服端"><a href="#客服端" class="headerlink" title="客服端"></a>客服端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/8 17:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8899</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                            client.finishConnect();</span><br><span class="line">                            System.out.println(client);</span><br><span class="line">                            ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">                            writeBuffer.put((LocalDateTime.now() + <span class="string">&quot; 连接成功&quot;</span>).getBytes());</span><br><span class="line">                            writeBuffer.flip();</span><br><span class="line">                            client.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                            ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">                            executorService.submit(() -&gt; &#123;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                    InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">                                    BufferedReader bf = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">                                    String message = bf.readLine();</span><br><span class="line">                                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">                                    buffer.put(message.getBytes());</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    client.write(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="keyword">int</span> read = client.read(byteBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            String message = <span class="keyword">new</span> String(byteBuffer.array());</span><br><span class="line">                            System.out.println(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                selectionKeys.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码还是比较复杂的，Netty 内部就是把这些细节给封装起来了</p>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>翻译过来为反应器模式，可以先看看由 Doug Lea 写的 <a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a> ，更好的理解 Netty 的设计模式</p>
<p>还有一篇博客也写得很好，介绍相关理论模型，使用场景，基本组件、整体架构，</p>
<p> <a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201811/586203.htm">这可能是目前最透彻的Netty原理架构解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1ccbc6a348db">Netty 那些事儿 ——— Reactor模式详解</a></p>
<p>Netty Reactor 工作架构图</p>
<center><img src="http://img.cuzz.site/20200915150058.png"></center>

<h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h2><p>前面通过 <code>.channel(NioServerSocketChannel.class)</code> 是为了通过反射创建一个 <code>NioServerSocketChannel</code> 对象</p>
<h3 id="NioServerSocketChannel"><a href="#NioServerSocketChannel" class="headerlink" title="NioServerSocketChannel"></a>NioServerSocketChannel</h3><p>使用反射创建 <code>NioServerSocketChannel</code> 肯定是通过无参数构造器，在调用 <code>newSocket(DEFAULT_SELECTOR_PROVIDER)</code> 所以这是一个静态方法，返回一个 <code>ServerSocketChannel</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> io.netty.channel.socket.ServerSocketChannel&#125; implementation which uses</span></span><br><span class="line"><span class="comment"> * NIO selector based implementation to accept new connections.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractNioMessageChannel</span></span></span><br><span class="line"><span class="class">                             <span class="keyword">implements</span> <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">socket</span>.<span class="title">ServerSocketChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ChannelMetadata METADATA = <span class="keyword">new</span> ChannelMetadata(<span class="keyword">false</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  Use the &#123;<span class="doctag">@link</span> SelectorProvider&#125; to open &#123;<span class="doctag">@link</span> SocketChannel&#125; and so remove condition in</span></span><br><span class="line"><span class="comment">             *  &#123;<span class="doctag">@link</span> SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *  See &lt;a href=&quot;https://github.com/netty/netty/issues/2308&quot;&gt;#2308&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                    <span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocketChannelConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance using the given &#123;<span class="doctag">@link</span> SelectorProvider&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(newSocket(provider));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance using the given &#123;<span class="doctag">@link</span> ServerSocketChannel&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractNioChannel"><a href="#AbstractNioChannel" class="headerlink" title="AbstractNioChannel"></a>AbstractNioChannel</h3><p>我们回到调用的这个构造方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一直调用父类，把 <code>SelectionKey.OP_ACCEPT</code> 设置上，还有设置非堵塞，是不出是很熟悉，这都是对 NIO 进行封装</p>
<p>io.netty.channel.nio.AbstractNioChannel#AbstractNioChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用父类，就是设置 Id 和创建管道</p>
<p>io.netty.channel.AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NioServerSocketChannelConfig"><a href="#NioServerSocketChannelConfig" class="headerlink" title="NioServerSocketChannelConfig"></a>NioServerSocketChannelConfig</h3><p>我们在回到这个构造方法上，我们重点来看看这个， <code>NioServerSocketChannelConfig</code> 这是一个配置类，Netty 的各种各样的信息都是体现在这个里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把自己和刚开始创建的 <code>NIOSocketChannel</code> 的 <code>ServerSocket</code> 对象传入进去</p>
<p>io.netty.channel.DefaultChannelConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultChannelConfig</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(channel, <span class="keyword">new</span> AdaptiveRecvByteBufAllocator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传了一个 <code>AdaptiveRecvByteBufAllocator</code> 翻译过来可以叫<strong>可适配的接受字节缓冲适配器</strong></p>
<h3 id="AdaptiveRecvByteBufAllocator"><a href="#AdaptiveRecvByteBufAllocator" class="headerlink" title="AdaptiveRecvByteBufAllocator"></a>AdaptiveRecvByteBufAllocator</h3><p>io.netty.channel.AdaptiveRecvByteBufAllocator</p>
<p>文档：</p>
<blockquote>
<p>The RecvByteBufAllocator that automatically increases and decreases the predicted buffer size on feed back.<br>It gradually increases the expected number of readable bytes if the previous read fully filled the allocated buffer. It gradually decreases the expected number of readable bytes if the read operation was not able to fill a certain amount of the allocated buffer two times consecutively. Otherwise, it keeps returning the same prediction.</p>
</blockquote>
<p>构造方法，默认是1024，最小是63，最大是65536</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new predictor with the default parameters.  With the default</span></span><br><span class="line"><span class="comment"> * parameters, the expected buffer size starts from &#123;<span class="doctag">@code</span> 1024&#125;, does not</span></span><br><span class="line"><span class="comment"> * go down below &#123;<span class="doctag">@code</span> 64&#125;, and does not go up above &#123;<span class="doctag">@code</span> 65536&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AdaptiveRecvByteBufAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_MINIMUM, DEFAULT_INITIAL, DEFAULT_MAXIMUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在看看里面的内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleImpl</span> <span class="keyword">extends</span> <span class="title">MaxMessageHandle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextReceiveBufferSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> decreaseNow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandleImpl</span><span class="params">(<span class="keyword">int</span> minIndex, <span class="keyword">int</span> maxIndex, <span class="keyword">int</span> initial)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minIndex = minIndex;</span><br><span class="line">        <span class="keyword">this</span>.maxIndex = maxIndex;</span><br><span class="line"></span><br><span class="line">        index = getSizeTableIndex(initial);</span><br><span class="line">        nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextReceiveBufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(<span class="keyword">int</span> actualReadBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (actualReadBytes &lt;= SIZE_TABLE[Math.max(<span class="number">0</span>, index - INDEX_DECREMENT - <span class="number">1</span>)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (decreaseNow) &#123;</span><br><span class="line">                index = Math.max(index - INDEX_DECREMENT, minIndex);</span><br><span class="line">                nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">                decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                decreaseNow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actualReadBytes &gt;= nextReceiveBufferSize) &#123;</span><br><span class="line">            index = Math.min(index + INDEX_INCREMENT, maxIndex);</span><br><span class="line">            nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">            decreaseNow = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        record(totalBytesRead());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其父亲 MaxMessageHandle 中，根据记录中的分配，计算出下一次分配的内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">allocate</span><span class="params">(ByteBufAllocator alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> alloc.ioBuffer(guess());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据系统的支持返回是<strong>堆内内存</strong>还是<strong>堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">ioBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        <span class="keyword">return</span> directBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>我们回到前面管道的创建</p>
<p>io.netty.channel.AbstractChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>io.netty.channel.DefaultChannelPipeline#DefaultChannelPipeline</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里维护了一个上下文，并且把 <code>Channel</code> 对象赋值给自己，所以 <code>Channel</code> 和 <code>Pipeline</code> 是相互引用的</p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>io.netty.channel.ChannelPipeline</p>
<p>文档：</p>
<p>A list of ChannelHandlers which handles or intercepts inbound events and outbound operations of a Channel. ChannelPipeline implements an advanced form of the Intercepting Filter pattern to give a user full control over how an event is handled and how the ChannelHandlers in a pipeline interact with each other.</p>
<p><strong>Creation of a pipeline</strong></p>
<p>Each channel has its own pipeline and it is created automatically when a new channel is created.</p>
<p><strong>How an event flows in a pipeline</strong></p>
<p>The following diagram describes how I/O events are processed by ChannelHandlers in a ChannelPipeline typically. An I/O event is handled by either a ChannelInboundHandler or a ChannelOutboundHandler and be forwarded to its closest handler by calling the event propagation methods defined in ChannelHandlerContext, such as ChannelHandlerContext.fireChannelRead(Object) and ChannelHandlerContext.write(Object).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                               I&#x2F;O Request</span><br><span class="line">                                          via Channel or</span><br><span class="line">                                      ChannelHandlerContext</span><br><span class="line">                                                    |</span><br><span class="line">+---------------------------------------------------+---------------+</span><br><span class="line">|                           ChannelPipeline         |               |</span><br><span class="line">|                                                  \|&#x2F;              |</span><br><span class="line">|    +---------------------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">|               |                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  .               |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">|        [ method call]                       [method call]         |</span><br><span class="line">|               .                                   .               |</span><br><span class="line">|               .                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">|               |                                  \|&#x2F;              |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line">|    +----------+----------+            +-----------+----------+    |</span><br><span class="line">|              &#x2F;|\                                  |               |</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">                |                                  \|&#x2F;</span><br><span class="line">+---------------+-----------------------------------+---------------+</span><br><span class="line">|               |                                   |               |</span><br><span class="line">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">|                                                                   |</span><br><span class="line">|  Netty Internal I&#x2F;O Threads (Transport Implementation)            |</span><br><span class="line">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>An inbound event is handled by the inbound handlers in the bottom-up direction as shown on the left side of the diagram. An inbound handler usually handles the inbound data generated by the I/O thread on the bottom of the diagram. The inbound data is often read from a remote peer via the actual input operation such as SocketChannel.read(ByteBuffer). If an inbound event goes beyond the top inbound handler, it is discarded silently, or logged if it needs your attention.</p>
<p>An outbound event is handled by the outbound handler in the top-down direction as shown on the right side of the diagram. An outbound handler usually generates or transforms the outbound traffic such as write requests. If an outbound event goes beyond the bottom outbound handler, it is handled by an I/O thread associated with the Channel. The I/O thread often performs the actual output operation such as SocketChannel.write(ByteBuffer)</p>
<p>For example, let us assume that we created the following pipeline:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelPipeline p = ...;</span><br><span class="line">p.addLast(<span class="string">&quot;1&quot;</span>, <span class="keyword">new</span> InboundHandlerA());</span><br><span class="line">p.addLast(<span class="string">&quot;2&quot;</span>, <span class="keyword">new</span> InboundHandlerB());</span><br><span class="line">p.addLast(<span class="string">&quot;3&quot;</span>, <span class="keyword">new</span> OutboundHandlerA());</span><br><span class="line">p.addLast(<span class="string">&quot;4&quot;</span>, <span class="keyword">new</span> OutboundHandlerB());</span><br><span class="line">p.addLast(<span class="string">&quot;5&quot;</span>, <span class="keyword">new</span> InboundOutboundHandlerX());</span><br></pre></td></tr></table></figure>

<p>In the example above, the class whose name starts with Inbound means it is an inbound handler. The class whose name starts with Outbound means it is a outbound handler.</p>
<p>In the given example configuration, the handler evaluation order is 1, 2, 3, 4, 5 when an event goes inbound. When an event goes outbound, the order is 5, 4, 3, 2, 1. On top of this principle, ChannelPipeline skips the evaluation of certain handlers to shorten the stack depth:</p>
<ul>
<li>3 and 4 don’t implement ChannelInboundHandler, and therefore the actual evaluation order of an inbound event will be: 1, 2, and 5.</li>
<li>1 and 2 don’t implement ChannelOutboundHandler, and therefore the actual evaluation order of a outbound event will be: 5, 4, and 3.</li>
<li>If 5 implements both ChannelInboundHandler and ChannelOutboundHandler, the evaluation order of an inbound and a outbound event could be 125 and 543 respectively.</li>
</ul>
<p><strong>Forwarding an event to the next handler</strong></p>
<p>As you might noticed in the diagram shows, a handler has to invoke the event propagation methods in ChannelHandlerContext to forward an event to its next handler. Those methods include:</p>
<ul>
<li>Inbound event propagation methods<ul>
<li>ChannelHandlerContext.fireChannelRegistered()</li>
<li>hannelHandlerContext.fireChannelActive()</li>
<li>ChannelHandlerContext.fireChannelRead(Object)</li>
<li>ChannelHandlerContext.fireChannelReadComplete()</li>
<li>ChannelHandlerContext.fireExceptionCaught(Throwable)</li>
<li>ChannelHandlerContext.fireUserEventTriggered(Object)</li>
<li>ChannelHandlerContext.fireChannelWritabilityChanged()</li>
<li>ChannelHandlerContext.fireChannelInactive()</li>
<li>ChannelHandlerContext.fireChannelUnregistered()</li>
</ul>
</li>
<li>Outbound event propagation methods:<ul>
<li>ChannelHandlerContext.bind(SocketAddress, ChannelPromise)</li>
<li>ChannelHandlerContext.connect(SocketAddress, SocketAddress, ChannelPromise)</li>
<li>ChannelHandlerContext.write(Object, ChannelPromise)</li>
<li>ChannelHandlerContext.flush()</li>
<li>ChannelHandlerContext.read()</li>
<li>ChannelHandlerContext.disconnect(ChannelPromise)</li>
<li>ChannelHandlerContext.close(ChannelPromise)</li>
<li>ChannelHandlerContext.deregister(ChannelPromise)</li>
</ul>
</li>
</ul>
<p>and the following example shows how the event propagation is usually done:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected!&quot;</span>);</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOutboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Closing ..&quot;</span>);</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Building a pipeline</strong> (重点)</p>
<p>A user is supposed to have one or more ChannelHandlers in a pipeline to receive I/O events (e.g. read) and to request I/O operations (e.g. write and close). For example, a typical server will have the following handlers in each channel’s pipeline, but your mileage may vary depending on the complexity and characteristics of the protocol and business logic:</p>
<ul>
<li>Protocol Decoder - translates binary data (e.g. ByteBuf) into a Java object.</li>
<li>Protocol Encoder - translates a Java object into binary data.</li>
<li>Business Logic Handler - performs the actual business logic (e.g. database access).</li>
</ul>
<p>and it could be represented as shown in the following example:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> EventExecutorGroup group = <span class="keyword">new</span> DefaultEventExecutorGroup(<span class="number">16</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> MyProtocolDecoder());</span><br><span class="line">pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> MyProtocolEncoder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the pipeline to run MyBusinessLogicHandler&#x27;s event handler methods</span></span><br><span class="line"><span class="comment">// in a different thread than an I/O thread so that the I/O thread is not blocked by</span></span><br><span class="line"><span class="comment">// a time-consuming task.</span></span><br><span class="line"><span class="comment">// If your business logic is fully asynchronous or finished very quickly, you don&#x27;t</span></span><br><span class="line"><span class="comment">// need to specify a group.</span></span><br><span class="line">pipeline.addLast(group, <span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> MyBusinessLogicHandler());</span><br></pre></td></tr></table></figure>

<p>注：可以使用重载这个方法添加一个事件循环组 group 去执行耗时的任务，获取在 MyBusinessLogicHandler 中把耗时部分异步处理，这样就不会堵塞 IO 线程</p>
<p><strong>Thread safety</strong></p>
<p>A ChannelHandler can be added or removed at any time because a ChannelPipeline is thread safe. For example, you can insert an encryption handler when sensitive information is about to be exchanged, and remove it after the exchange.</p>
<p><strong>对于传统的过滤器如 <code>SpringMVC</code> 比如我们配置了 <code>Filter1</code> <code>Filter2</code> <code>Filter3</code> 过滤器，请求和返回都要经过滤器这3个过滤器，而管道可以选择的其中某些作为请求的过滤器，一些作为返回的过滤器，不一定要一样，入站的处理器专门处理入站的，出站的处理器专门处理出站的</strong></p>
<h2 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h2><p>io.netty.bootstrap.ServerBootstrap#init</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h3><p>类图</p>
<center><img src="http://img.cuzz.site/20200915150146.png"></center>

<blockquote>
<p>io.netty.channel<br>public class ChannelOption<T><br>extends AbstractConstant&lt;ChannelOption<T>&gt;</T></T></p>
<p>A ChannelOption allows to configure a ChannelConfig in a type-safe way. Which ChannelOption is supported depends on the actual implementation of ChannelConfig and may depend on the nature of the transport it belongs to.</p>
<p>Type parameters:<br><T> - the type of the value which is valid for the ChannelOption</T></p>
</blockquote>
<p><code>ChannelOption &lt;T&gt;</code> 主要维护 TCP/IP 的一些底层的设定，T 表示值的类型</p>
<p><code>ChannelOption</code> 继承了 <code>AbstractConstant</code>， <code>AbstractConstant</code> 有是 <code>Constant</code> 的一个基本的实现</p>
<p>io.netty.util.Constant</p>
<blockquote>
<p>io.netty.util<br>public interface Constant&lt;T extends Constant<T>&gt;<br>extends Comparable<T></T></T></p>
<p>A singleton which is safe to compare via the == operator. Created and managed by ConstantPool.</p>
<p>Type parameters:<br><T> - the type of objects that this object may be compared to</T></p>
</blockquote>
<p>我们可以知道这个常量是由 <code>ConstantPool</code> 来维持的，我看看他是怎么起作用的</p>
<p>io.netty.util.ConstantPool</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantPool</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Constant</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, T&gt; constants = PlatformDependent.newConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shortcut of &#123;<span class="doctag">@link</span> #valueOf(String) valueOf(firstNameComponent.getName() + &quot;#&quot; + secondNameComponent)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">valueOf</span><span class="params">(Class&lt;?&gt; firstNameComponent, String secondNameComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (firstNameComponent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;firstNameComponent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secondNameComponent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;secondNameComponent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valueOf(firstNameComponent.getName() + <span class="string">&#x27;#&#x27;</span> + secondNameComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> Constant&#125; which is assigned to the specified &#123;<span class="doctag">@code</span> name&#125;.</span></span><br><span class="line"><span class="comment">     * If there&#x27;s no such &#123;<span class="doctag">@link</span> Constant&#125;, a new one will be created and returned.</span></span><br><span class="line"><span class="comment">     * Once created, the subsequent calls with the same &#123;<span class="doctag">@code</span> name&#125; will always return the previously created one</span></span><br><span class="line"><span class="comment">     * (i.e. singleton.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the &#123;<span class="doctag">@link</span> Constant&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        checkNotNullAndNotEmpty(name);</span><br><span class="line">        <span class="keyword">return</span> getOrCreate(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get existing constant by name or creates new one if not exists. Threadsafe</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the &#123;<span class="doctag">@link</span> Constant&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">getOrCreate</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        T constant = constants.get(name);</span><br><span class="line">        <span class="keyword">if</span> (constant == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> T tempConstant = newConstant(nextId(), name);</span><br><span class="line">            constant = constants.putIfAbsent(name, tempConstant);</span><br><span class="line">            <span class="keyword">if</span> (constant == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> tempConstant;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> constant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if a &#123;<span class="doctag">@link</span> AttributeKey&#125; exists for the given &#123;<span class="doctag">@code</span> name&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        checkNotNullAndNotEmpty(name);</span><br><span class="line">        <span class="keyword">return</span> constants.containsKey(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> Constant&#125; for the given &#123;<span class="doctag">@code</span> name&#125; or fail with an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> IllegalArgumentException&#125; if a &#123;<span class="doctag">@link</span> Constant&#125; for the given &#123;<span class="doctag">@code</span> name&#125; exists.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        checkNotNullAndNotEmpty(name);</span><br><span class="line">        <span class="keyword">return</span> createOrThrow(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates constant by name or throws exception. Threadsafe</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the &#123;<span class="doctag">@link</span> Constant&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">createOrThrow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        T constant = constants.get(name);</span><br><span class="line">        <span class="keyword">if</span> (constant == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> T tempConstant = newConstant(nextId(), name);</span><br><span class="line">            constant = constants.putIfAbsent(name, tempConstant);</span><br><span class="line">            <span class="keyword">if</span> (constant == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> tempConstant;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;&#x27;%s&#x27; is already in use&quot;</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">checkNotNullAndNotEmpty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;empty name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">newConstant</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看这个创建方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get existing constant by name or creates new one if not exists. Threadsafe</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the &#123;<span class="doctag">@link</span> Constant&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">getOrCreate</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    T constant = constants.get(name);</span><br><span class="line">    <span class="keyword">if</span> (constant == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> T tempConstant = newConstant(nextId(), name);</span><br><span class="line">        constant = constants.putIfAbsent(name, tempConstant);</span><br><span class="line">        <span class="keyword">if</span> (constant == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tempConstant;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> constant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了双重检验机制，这个常量池保存的值是一个 <code>T extends Constant&lt;T&gt;</code> 包装过后的</p>
<p>io.netty.util.ConstantPool#newConstant</p>
<p>新建一个常量是由子类完成的，我们回到 <code>ChannelOption</code> 类中，**<code>ChannelOption</code> 是不保存值的，只是维护键的包装**</p>
<h3 id="AttributeKey"><a href="#AttributeKey" class="headerlink" title="AttributeKey"></a>AttributeKey</h3><p>io.netty.util.AttributeKey</p>
<blockquote>
<p>io.netty.util<br>public final class AttributeKey<T><br>extends AbstractConstant&lt;AttributeKey<T>&gt;</T></T></p>
<p>Key which can be used to access Attribute out of the AttributeMap. Be aware that it is not be possible to have multiple keys with the same name.</p>
<p>Type parameters:<br><T> - the type of the Attribute which can be accessed via this AttributeKey.</T></p>
</blockquote>
<p>与 ChannelOption 很相似，<code>AttributeMap</code> ，<code>AttributeKey</code> ，<code>Attribute</code> 相当一个 Map，key 和 value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds &#123;<span class="doctag">@link</span> Attribute&#125;s which can be accessed via &#123;<span class="doctag">@link</span> AttributeKey&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implementations must be Thread-safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the &#123;<span class="doctag">@link</span> Attribute&#125; for the given &#123;<span class="doctag">@link</span> AttributeKey&#125;. This method will never return null, but may return</span></span><br><span class="line"><span class="comment">     * an &#123;<span class="doctag">@link</span> Attribute&#125; which does not have a value set yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Attribute&lt;T&gt; <span class="title">attr</span><span class="params">(AttributeKey&lt;T&gt; key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span>&#125; true if and only if the given &#123;<span class="doctag">@link</span> Attribute&#125; exists in this &#123;<span class="doctag">@link</span> AttributeMap&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttr</span><span class="params">(AttributeKey&lt;T&gt; key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要维护的是业务数据，可以在程序运行中动态的往里面添加数据和获取数据</p>
<h3 id="ChannelInitializer"><a href="#ChannelInitializer" class="headerlink" title="ChannelInitializer"></a>ChannelInitializer</h3><p>io.netty.bootstrap.ServerBootstrap#init</p>
<p>回到 init 方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取管道添加了一个 <code>ChannelInitializer</code> 实例，先看看这个类</p>
<p>io.netty.channel.ChannelInitializer</p>
<blockquote>
<p>io.netty.channel<br>@Sharable<br>public abstract class ChannelInitializer<C extends channel><br>extends ChannelInboundHandlerAdapter</C></p>
<p>A special ChannelInboundHandler which offers an easy way to initialize a Channel once it was registered to its EventLoop. Implementations are most often used in the context of Bootstrap.handler(ChannelHandler) , ServerBootstrap.handler(ChannelHandler) and ServerBootstrap.childHandler(ChannelHandler) to setup the ChannelPipeline of a Channel.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        channel.pipeline().addLast(<span class="string">&quot;myHandler&quot;</span>, <span class="keyword">new</span> MyHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ServerBootstrap bootstrap = ...;</span><br><span class="line">...</span><br><span class="line">bootstrap.childHandler(<span class="keyword">new</span> MyChannelInitializer());</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Be aware that this class is marked as ChannelHandler.Sharable and so the implementation must be safe to be re-used.</p>
<p>Type parameters:<br><C> -  A sub-type of Channel</C></p>
</blockquote>
<h2 id="addLast-方法"><a href="#addLast-方法" class="headerlink" title="addLast() 方法"></a>addLast() 方法</h2><p>io.netty.channel.DefaultChannelPipeline#addLast</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractChannelHandlerContext</code> 定义了一个上下文，找到实现的一个接口 <code>ChannelHandlerContext</code></p>
<p>io.netty.channel.ChannelHandlerContext</p>
<p>文档：<a target="_blank" rel="noopener" href="https://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html">https://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html</a></p>
<p>接下来我分析一下 <code>ChannelHandlerContext</code> ，<code>PipeLine</code>，<code>Handler</code> 这三者的关系。</p>
<p>加油！！！</p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="link-muted mr-2" rel="tag" href="/tags/NIO/">NIO</a><a class="link-muted mr-2" rel="tag" href="/tags/Reactor/">Reactor</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/01/16/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Netty 源码分析（三）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/01/03/Netty_%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><span class="level-item">Netty 源码分析（一）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "6f4544cb40564167fbf9d7d337c0fe02",
            repo: "cuzz1.github.io",
            owner: "cuzz1",
            clientID: "e829281603f9115c572d",
            clientSecret: "246dae10dfb1b363805ab98902dc93539c355bb3",
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#先来看一个NIO网络编程"><span class="mr-2">1</span><span>先来看一个NIO网络编程</span></a><ul class="menu-list"><li><a class="is-flex" href="#服务端"><span class="mr-2">1.1</span><span>服务端</span></a></li><li><a class="is-flex" href="#客服端"><span class="mr-2">1.2</span><span>客服端</span></a></li></ul></li><li><a class="is-flex" href="#Reactor模式"><span class="mr-2">2</span><span>Reactor模式</span></a></li><li><a class="is-flex" href="#bind-方法"><span class="mr-2">3</span><span>bind() 方法</span></a><ul class="menu-list"><li><a class="is-flex" href="#NioServerSocketChannel"><span class="mr-2">3.1</span><span>NioServerSocketChannel</span></a></li><li><a class="is-flex" href="#AbstractNioChannel"><span class="mr-2">3.2</span><span>AbstractNioChannel</span></a></li><li><a class="is-flex" href="#NioServerSocketChannelConfig"><span class="mr-2">3.3</span><span>NioServerSocketChannelConfig</span></a></li><li><a class="is-flex" href="#AdaptiveRecvByteBufAllocator"><span class="mr-2">3.4</span><span>AdaptiveRecvByteBufAllocator</span></a></li><li><a class="is-flex" href="#Pipeline"><span class="mr-2">3.5</span><span>Pipeline</span></a></li><li><a class="is-flex" href="#ChannelPipeline"><span class="mr-2">3.6</span><span>ChannelPipeline</span></a></li></ul></li><li><a class="is-flex" href="#init-方法"><span class="mr-2">4</span><span>init() 方法</span></a><ul class="menu-list"><li><a class="is-flex" href="#ChannelOption"><span class="mr-2">4.1</span><span>ChannelOption</span></a></li><li><a class="is-flex" href="#AttributeKey"><span class="mr-2">4.2</span><span>AttributeKey</span></a></li><li><a class="is-flex" href="#ChannelInitializer"><span class="mr-2">4.3</span><span>ChannelInitializer</span></a></li></ul></li><li><a class="is-flex" href="#addLast-方法"><span class="mr-2">5</span><span>addLast() 方法</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>