<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Netty 源码分析（四） - Hexo</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="Netty 源码分析（四）"><meta property="og:url" content="http://blog.cuzz.site/2019/01/19/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://blog.cuzz.site/img/og_image.png"><meta property="article:published_time" content="2019-01-18T16:00:07.000Z"><meta property="article:modified_time" content="2020-08-21T12:42:19.217Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="源码"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2019/01/19/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"},"headline":"Hexo","image":["http://blog.cuzz.site/img/og_image.png"],"datePublished":"2019-01-18T16:00:07.000Z","dateModified":"2020-08-21T12:42:19.217Z","author":{"@type":"Person","name":"John Doe"},"description":"版本 4.1.15    官网：https:&#x2F;&#x2F;netty.io&#x2F;  Netty is an asynchronous event-driven network application framework  for rapid development of maintainable high performance protocol servers &amp; clients."}</script><link rel="canonical" href="http://blog.cuzz.site/2019/01/19/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-18T16:00:07.000Z" title="2019-01-18T16:00:07.000Z">2019-01-19</time><span class="level-item"><a class="link-muted" href="/categories/Netty/">Netty</a></span><span class="level-item">26 minutes read (About 3911 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Netty 源码分析（四）</h1><div class="content"><p>版本 4.1.15   </p>
<p>官网：<a target="_blank" rel="noopener" href="https://netty.io/">https://netty.io/</a></p>
<blockquote>
<p>Netty is <em>an asynchronous event-driven network application framework</em>  for rapid development of maintainable high performance protocol servers &amp; clients. </p>
</blockquote>
<a id="more"></a>

<h2 id="ChannelPromise"><a href="#ChannelPromise" class="headerlink" title="ChannelPromise"></a>ChannelPromise</h2><p>io.netty.channel.ChannelPromise</p>
<p>前面我们分析了 <code>ChannelFuture</code> ，看看<code>ChannelPromise</code> 的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Special &#123;<span class="doctag">@link</span> ChannelFuture&#125; which is writable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelPromise</span> <span class="keyword">extends</span> <span class="title">ChannelFuture</span>, <span class="title">Promise</span>&lt;<span class="title">Void</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个可以写入的 <code>ChannelFuture</code> ，我先看看 <code>Promise</code> 这个类</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>io.netty.util.concurrent.Promise</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marks this future as a success and notifies all</span></span><br><span class="line"><span class="comment">     * listeners.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If it is success or failed already it will throw an &#123;<span class="doctag">@link</span> IllegalStateException&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marks this future as a success and notifies all</span></span><br><span class="line"><span class="comment">     * listeners.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if successfully marked this future as</span></span><br><span class="line"><span class="comment">     *         a success. Otherwise &#123;<span class="doctag">@code</span> false&#125; because this future is</span></span><br><span class="line"><span class="comment">     *         already marked as either a success or a failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marks this future as a failure and notifies all</span></span><br><span class="line"><span class="comment">     * listeners.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If it is success or failed already it will throw an &#123;<span class="doctag">@link</span> IllegalStateException&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Marks this future as a failure and notifies all</span></span><br><span class="line"><span class="comment">     * listeners.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if successfully marked this future as</span></span><br><span class="line"><span class="comment">     *         a failure. Otherwise &#123;<span class="doctag">@code</span> false&#125; because this future is</span></span><br><span class="line"><span class="comment">     *         already marked as either a success or a failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make this future impossible to cancel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if and only if successfully marked this future as uncancellable or it is already done</span></span><br><span class="line"><span class="comment">     *         without being cancelled.  &#123;<span class="doctag">@code</span> false&#125; if this future has been cancelled already.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 所提供的的 Future 只能通过手工的方式检查执行结果，而这个操作是会阻塞的；Netty 则对 ChannelFutre 进行了增强，通过 ChannelFutureListener 以回调的方式来获取执行结果，去除了手工检查阻塞的操作，值得注意的是，ChannelFutrureListener 的 operationComplete 方法是由I/O线程执行的，因此要注意的是不要在这里执行耗时操作，否则需要通过另外的线程或线程池来执行</p>
<h2 id="ChannelInboundHandlerAdapter"><a href="#ChannelInboundHandlerAdapter" class="headerlink" title="ChannelInboundHandlerAdapter"></a>ChannelInboundHandlerAdapter</h2><p>io.netty.channel.ChannelInboundHandlerAdapter</p>
<blockquote>
<p>io.netty.channel<br>public class ChannelInboundHandlerAdapter<br>extends ChannelHandlerAdapter</p>
<p>implements ChannelInboundHandlerAbstract base class for ChannelInboundHandler implementations which provide implementations of all of their methods.</p>
<p>This implementation just forward the operation to the next ChannelHandler in the ChannelPipeline. Sub-classes may override a method implementation to change this.</p>
<p>Be aware that messages are not released after the channelRead(ChannelHandlerContext, Object) method returns automatically. If you are looking for a ChannelInboundHandler implementation that releases the received messages automatically, please see SimpleChannelInboundHandler.</p>
</blockquote>
<p>这里使用了适配器模式</p>
<h3 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h3><p>io.netty.channel.ChannelInboundHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ChannelHandler&#125; which adds callbacks for state changes. This allows the user</span></span><br><span class="line"><span class="comment"> * to hook in to state changes easily.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; was registered with its &#123;<span class="doctag">@link</span> EventLoop&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; was unregistered from its &#123;<span class="doctag">@link</span> EventLoop&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; is now active</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; was registered is now inactive and reached its</span></span><br><span class="line"><span class="comment">     * end of lifetime.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the current &#123;<span class="doctag">@link</span> Channel&#125; has read a message from the peer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when the last message read by the current read operation has been consumed by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #channelRead(ChannelHandlerContext, Object)&#125;.  If &#123;<span class="doctag">@link</span> ChannelOption#AUTO_READ&#125; is off, no further</span></span><br><span class="line"><span class="comment">     * attempt to read an inbound data from the current &#123;<span class="doctag">@link</span> Channel&#125; will be made until</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ChannelHandlerContext#read()&#125; is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called if an user event was triggered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called once the writable state of a &#123;<span class="doctag">@link</span> Channel&#125; changed. You can check the state with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Channel#isWritable()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets called if a &#123;<span class="doctag">@link</span> Throwable&#125; was thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleChannelInboundHandler"><a href="#SimpleChannelInboundHandler" class="headerlink" title="SimpleChannelInboundHandler"></a>SimpleChannelInboundHandler</h2><p>io.netty.channel.SimpleChannelInboundHandler</p>
<p>我们在写自己的 Handler 的时候长会继承这个 SimpleChannelInboundHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot;: &quot;</span> + msg);</span><br><span class="line">        ctx.channel().writeAndFlush(<span class="string">&quot;from server: &quot;</span> + UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出现异常关闭连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看这个文档</p>
<blockquote>
<p>io.netty.channel<br>public abstract class SimpleChannelInboundHandler<I><br>extends ChannelInboundHandlerAdapter<br>ChannelInboundHandlerAdapter which allows to explicit only handle a specific type of messages. For example here is an implementation which only handle String messages.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHandler</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String message)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Be aware that depending of the constructor parameters it will release all handled messages by passing them to ReferenceCountUtil.release(Object). In this case you may need to use ReferenceCountUtil.retain(Object) if you pass the object to the next handler in the ChannelPipeline.<br>Forward compatibility notice</p>
</blockquote>
<p>我们可以通过泛型指定消息类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> release = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptInboundMessage(msg)) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            I imsg = (I) msg;</span><br><span class="line">            channelRead0(ctx, imsg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            release = <span class="keyword">false</span>;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (autoRelease &amp;&amp; release) &#123;</span><br><span class="line">            <span class="comment">// 把这个消息计数减一，当减为0就丢弃</span></span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;Please keep in mind that this method will be renamed to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> messageReceived(ChannelHandlerContext, I)&#125; in 5.0.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Is called for each message of type &#123;<span class="doctag">@link</span> I&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx           the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; which this &#123;<span class="doctag">@link</span> SimpleChannelInboundHandler&#125;</span></span><br><span class="line"><span class="comment"> *                      belongs to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg           the message to handle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception    is thrown if an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, I msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>给我们强制转换为特定的类型，再调用 channelRead0 方法，这是一个抽象方法，需要我们自己去实现</p>
<h3 id="ReferenceCounted"><a href="#ReferenceCounted" class="headerlink" title="ReferenceCounted"></a>ReferenceCounted</h3><p>io.netty.util.ReferenceCounted</p>
<blockquote>
<p>io.netty.util<br>public interface ReferenceCounted<br>A reference-counted object that requires explicit deallocation.<br>When a new ReferenceCounted is instantiated, it starts with the reference count of 1. retain() increases the reference count, and release() decreases the reference count. If the reference count is decreased to 0, the object will be deallocated explicitly, and accessing the deallocated object will usually result in an access violation.<br>If an object that implements ReferenceCounted is a container of other objects that implement ReferenceCounted, the contained objects will also be released via release() when the container’s reference count becomes 0.</p>
</blockquote>
<h2 id="ctx-channel-write-和ctx-write-的区别"><a href="#ctx-channel-write-和ctx-write-的区别" class="headerlink" title="ctx.channel().write()和ctx.write()的区别"></a>ctx.channel().write()和ctx.write()的区别</h2><p>在 Netty 中有两种发消息的方式，可以直接写到 Channel 中，也可以写到与 ChannelHandler 所关联的那个 ChannelHandlerContext 中，对于 <code>ctx.channel().write()</code> 方式来说，消息会从 ChannelPipeline 的末尾开始流动，对于 <code>ctx.write()</code> 来说，消息将从 ChannelPipeline 中的下一个 ChannelHandler 开始流动</p>
<p>这篇博客个解释了</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/FishSeeker/article/details/78447684">https://blog.csdn.net/FishSeeker/article/details/78447684</a></p>
<p>结论：</p>
<ol>
<li>ChannelHandlerContext 与 ChannelHandler 之间的关联绑定关系是永远不会发生改变的，因此对其进行缓存时没有任何问题的</li>
<li>对于与 Channel 的同名方法来说， ChannelHandlerContext 的方法将会产生更短的事件流，所以我们因该在可能的情况下利用这个特性来提升性能</li>
</ol>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="NIO-总结"><a href="#NIO-总结" class="headerlink" title="NIO 总结"></a>NIO 总结</h3><p>使用 NIO 进行文件读取所涉及的步骤：</p>
<ol>
<li>从 FileInputStream 对象获取到 Channel 对象</li>
<li>创建 Buffer</li>
<li>将数据从 Channel 中读取到Buffer中</li>
</ol>
<p>![20190118000012](Netty 源码分析（四）\20190118000012.png)</p>
<p>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<p>flip() 方法：</p>
<ol>
<li>将 limit 值设置为当前的 position</li>
<li>将 position 设置 0</li>
</ol>
<p>clear() 方法：</p>
<ol>
<li>将 limit 设置为capacity</li>
<li>将 position 设置为0</li>
</ol>
<p>compact() 方法：</p>
<ol>
<li>将所有未读的数据复制到 buffer 起始的位置处</li>
<li>将 position 设置为最后一个未读元素的后面</li>
<li>将 limit 设置为 capacity</li>
<li>现在buffer 就准备好了，但是不会覆盖未读的数据</li>
</ol>
<h3 id="Java-NIO中，关于DirectBuffer，HeapBuffer的疑问？"><a href="#Java-NIO中，关于DirectBuffer，HeapBuffer的疑问？" class="headerlink" title="Java NIO中，关于DirectBuffer，HeapBuffer的疑问？"></a>Java NIO中，关于DirectBuffer，HeapBuffer的疑问？</h3><blockquote>
<ol>
<li><p>DirectBuffer 属于堆外存，那应该还是属于用户内存，而不是内核内存？</p>
</li>
<li><p>FileChannel 的read(ByteBuffer dst)函数,write(ByteBuffer src)函数中，如果传入的参数是HeapBuffer类型,则会临时申请一块DirectBuffer,进行数据拷贝，而不是直接进行数据传输，这是出于什么原因？</p>
</li>
</ol>
</blockquote>
<p><strong>答案：</strong> <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/57374068/answer/152691891">https://www.zhihu.com/question/57374068/answer/152691891</a></p>
<p>Java NIO中的direct buffer（主要是DirectByteBuffer）其实是分两部分的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Java        |      native</span><br><span class="line">                  |</span><br><span class="line">DirectByteBuffer  |     malloc&#39;d</span><br><span class="line">[    address   ] -+-&gt; [   data    ]</span><br><span class="line">                  |</span><br></pre></td></tr></table></figure>

<p>其中 DirectByteBuffer 自身是一个Java对象，在Java堆中；而这个对象中有个long类型字段address，记录着一块调用 malloc() 申请到的native memory。</p>
<p>所以回到题主的问题：</p>
<blockquote>
<p>\1. DirectBuffer 属于堆外存，那应该还是属于用户内存，而不是内核内存？</p>
</blockquote>
<p>DirectByteBuffer 自身是（Java）堆内的，它背后真正承载数据的buffer是在（Java）堆外——native memory中的。这是 malloc() 分配出来的内存，是用户态的。</p>
<blockquote>
<p>\2. FileChannel 的read(ByteBuffer dst)函数,write(ByteBuffer src)函数中，如果传入的参数是HeapBuffer类型,则会临时申请一块DirectBuffer,进行数据拷贝，而不是直接进行数据传输，这是出于什么原因？</p>
</blockquote>
<p>题主看的是OpenJDK的 sun.nio.ch.IOUtil.write(FileDescriptor fd, ByteBuffer src, long position, NativeDispatcher nd) 的实现对不对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int write(FileDescriptor fd, ByteBuffer src, long position,</span><br><span class="line">                 NativeDispatcher nd)</span><br><span class="line">    throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    if (src instanceof DirectBuffer)</span><br><span class="line">        return writeFromNativeBuffer(fd, src, position, nd);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Substitute a native buffer</span><br><span class="line">    int pos &#x3D; src.position();</span><br><span class="line">    int lim &#x3D; src.limit();</span><br><span class="line">    assert (pos &lt;&#x3D; lim);</span><br><span class="line">    int rem &#x3D; (pos &lt;&#x3D; lim ? lim - pos : 0);</span><br><span class="line">    ByteBuffer bb &#x3D; Util.getTemporaryDirectBuffer(rem);</span><br><span class="line">    try &#123;</span><br><span class="line">        bb.put(src);</span><br><span class="line">        bb.flip();</span><br><span class="line">        &#x2F;&#x2F; Do not update src until we see how many bytes were written</span><br><span class="line">        src.position(pos);</span><br><span class="line"></span><br><span class="line">        int n &#x3D; writeFromNativeBuffer(fd, bb, position, nd);</span><br><span class="line">        if (n &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; now update src</span><br><span class="line">            src.position(pos + n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Util.offerFirstTemporaryDirectBuffer(bb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实是在迁就OpenJDK里的HotSpot VM的一点实现细节。</p>
<p>HotSpot VM里的GC除了CMS之外都是要移动对象的，是所谓“compacting GC”。</p>
<p>如果要把一个Java里的 byte[] 对象的引用传给native代码，让native代码直接访问数组的内容的话，就必须要保证native代码在访问的时候这个 byte[] 对象不能被移动，也就是要被“pin”（钉）住。</p>
<p>可惜HotSpot VM出于一些取舍而决定不实现单个对象层面的object pinning，要pin的话就得暂时禁用GC——也就等于把整个Java堆都给pin住。HotSpot VM对JNI的Critical系API就是这样实现的。这用起来就不那么顺手。</p>
<p>所以 Oracle/Sun JDK / OpenJDK 的这个地方就用了点绕弯的做法。它假设把 HeapByteBuffer 背后的 byte[] 里的内容拷贝一次是一个时间开销可以接受的操作，同时假设真正的I/O可能是一个很慢的操作。</p>
<p>于是它就先把 HeapByteBuffer 背后的 byte[] 的内容拷贝到一个 DirectByteBuffer 背后的native memory去，这个拷贝会涉及 sun.misc.Unsafe.copyMemory() 的调用，背后是类似 memcpy() 的实现。这个操作本质上是会在整个拷贝过程中暂时不允许发生GC的，虽然实现方式跟JNI的Critical系API不太一样。（具体来说是 Unsafe.copyMemory() 是HotSpot VM的一个intrinsic方法，中间没有safepoint所以GC无法发生）。</p>
<p>然后数据被拷贝到native memory之后就好办了，就去做真正的I/O，把 DirectByteBuffer 背后的native memory地址传给真正做I/O的函数。这边就不需要再去访问Java对象去读写要做I/O的数据了。</p>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>文档：<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/index.html">https://netty.io/4.1/api/index.html</a></p>
<p>我们看第一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, index = <span class="number">120</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(index + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(buffer.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">-128</span><br><span class="line">-127</span><br></pre></td></tr></table></figure>

<p>我们来看看这个方法的文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the specified byte at the current &#123;<span class="doctag">@code</span> writerIndex&#125;</span></span><br><span class="line"><span class="comment"> * and increases the &#123;<span class="doctag">@code</span> writerIndex&#125; by &#123;<span class="doctag">@code</span> 1&#125; in this buffer.</span></span><br><span class="line"><span class="comment"> * The 24 high-order bits of the specified value are ignored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *         if &#123;<span class="doctag">@code</span> this.writableBytes&#125; is less than &#123;<span class="doctag">@code</span> 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>虽然传入的一个 int 值，可是它会丢弃高位的 24 bit，我们知道 int 是 4 字节（32 bit），丢弃 3 字节 （24 bit），就保留到 1 字节（8 bit）</p>
<p>我们要看下一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello world&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为堆缓存，如果是堆缓存，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = byteBuf.array();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">            System.out.println(byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset());  <span class="comment">// 可读字节第一偏移量</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex());</span><br><span class="line">            System.out.println(byteBuf.writerIndex());</span><br><span class="line">            System.out.println(byteBuf.capacity());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world                      </span><br><span class="line">UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: 0, widx: 11, cap: 33)</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">11</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>ridx 表示读的 index，widx 表示写的 index</p>
<p>我们来看看复合 Buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个复合 buffer</span></span><br><span class="line">        CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class="line"></span><br><span class="line">        ByteBuf heapBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        ByteBuf directBuf = Unpooled.directBuffer(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        compositeByteBuf.addComponent(heapBuf);</span><br><span class="line">        compositeByteBuf.addComponent(directBuf);</span><br><span class="line"></span><br><span class="line">        compositeByteBuf.forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// UnpooledSlicedByteBuf(ridx: 0, widx: 0, cap: 0/0, unwrapped: UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: 0, widx: 0, cap: 10))</span></span><br><span class="line">        <span class="comment">// UnpooledSlicedByteBuf(ridx: 0, widx: 0, cap: 0/0, unwrapped: UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(ridx: 0, widx: 0, cap: 8))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Netty-提供的-3-种缓冲区"><a href="#Netty-提供的-3-种缓冲区" class="headerlink" title="Netty 提供的 3 种缓冲区"></a>Netty 提供的 3 种缓冲区</h3><p><strong>heap buffer（堆缓冲区）：</strong></p>
<p>这是最常见的类型，ByteBuf 将数据存储到 JVM 的堆空间中，并且将实际的数据放到 byte 数组中来实现的</p>
<p>优点：由于数据是存储在 JVM 的堆中，因此可以快速的创建和快速的释放，并且它提供了 直接访问内部字节数组的方法</p>
<p>缺点：每次读写数据时，都需要先将数据复制到直接缓冲中再进行网络传输</p>
<p><strong>direct buffer（直接缓冲区）：</strong></p>
<p>在堆之外直接分配内存空间，直接缓冲区并不会占用堆的容量空间，因为他是有操作系统在本地内存进行的数据分配</p>
<p>优点：在使用 Socket 进行数据传输时，性能非常好，因为数据直接位于操作系统的本地内存中，所以不需要从 JVM 将数据复制到直接缓冲区</p>
<p>缺点：因为 Direct Buffer 是直接在操作系统内存中的，所以内存空间分配与释放要比堆空间更加复杂，而且速度要慢一些</p>
<p>Netty 通过提供内存池来解决这个问题，直接缓冲区并不支持通过字节数组的方式来访问数据</p>
<p>重点：对于后端的业务消息的编解码来说，推荐使用 HeapByteBuf；对于 I/O 通信的读写缓冲区，我们推荐使用 DirectBytebuf</p>
<p><strong>composite buffer（符合缓冲区）：</strong></p>
<p>复合缓冲区实际上是将多个缓冲区实例组合起来，并向外提供一个统一视图。像是一个缓冲区的 List</p>
<h3 id="JDK-的-ByteBuffer-与-Netty-的-ByteBuf-之间的差异比对"><a href="#JDK-的-ByteBuffer-与-Netty-的-ByteBuf-之间的差异比对" class="headerlink" title="JDK 的 ByteBuffer 与 Netty 的 ByteBuf 之间的差异比对"></a>JDK 的 ByteBuffer 与 Netty 的 ByteBuf 之间的差异比对</h3><ol>
<li>Netty 的 ByteBuf 采用了读写分离的策略（readerIndex 和 writeerIndex），一个初始化（里面尚未有任何数据）的 ByteBuf 的 readerIndex 与 writerIndex 的值都为0</li>
<li>当数索引与写索引处于同一个位置时，如果我们继续读取，那么就会抛出 IndexOutOfBoundsException</li>
<li>对于ByteBuf 的任何读写操作都会分别单独维护读索引和写索引，MaxCapacity 最大的容量默认为Integer.MAX_VALUE</li>
</ol>
<p>![ByteBuf internal segmentation](Netty 源码分析（四）\ByteBuf internal segmentation.jpg)</p>
<p>JDK 的 ByteBuffer的缺点：</p>
<ol>
<li>final byte[] hb; 这是JDK的ByteBuffer对象中用于储存的对象声明，可以看到，其字节数组布尔声明为final的，也就是长度是固定不变的，一旦分配好后就不能动态扩容与收缩，而且当储存的数据字节很大时就很有可能出现IndexOutOfBoundsException，如果要预防着个异常，那就需要再储存之前完全确定好待储存的字节的大小，如果ByteBuffer的空间不足，我们只有一种解决方案，那就是创建新的ByteBuffer对象，然后再将之前的ByteBuffer中的数据复制过去，这一切操作都需要由开发者自己来手动完成的</li>
<li>ByteBuffer 只使用一个position 指针来标识位置信息，在进行读写切换时就需要调用flip方法或则是rewind 方法，使用很不方便</li>
</ol>
<p>Netty 的 ByteBuf 的优点：</p>
<ol>
<li>储存字节的数组是动态的，其最大值默认是Integer.MAX_VALUE，这里的动态性是体现在write方法中的，write方法执行会判断buffer容量，如果不足则会自动扩容</li>
<li>ByteBuf的读写索引是完成分开的，使用起来很方便</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.AbstractByteBuf#writeByte</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">writeByte</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">       ensureWritable0(<span class="number">1</span>);   <span class="comment">// 会先判断是否够写入一个字节</span></span><br><span class="line">       _setByte(writerIndex++, value);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.buffer.AbstractByteBuf#ensureWritable0</span></span><br><span class="line"><span class="comment">// 会自动扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">       ensureAccessible();</span><br><span class="line">       <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (minWritableBytes &gt; maxCapacity - writerIndex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                   <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                   writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Normalize the current capacity to the power of 2.</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Adjust to the new capacity.</span></span><br><span class="line">       capacity(newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" style="background-color:rgba(255,128,62,.87);border-color:transparent;color:white;" target="_blank" rel="noopener"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button is-danger donate" href="/" target="_blank" rel="noopener"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/01/22/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Netty 源码分析（五）</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/01/16/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><span class="level-item">Netty 源码分析（三）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#ChannelPromise"><span class="mr-2">1</span><span>ChannelPromise</span></a><ul class="menu-list"><li><a class="is-flex" href="#Promise"><span class="mr-2">1.1</span><span>Promise</span></a></li></ul></li><li><a class="is-flex" href="#ChannelInboundHandlerAdapter"><span class="mr-2">2</span><span>ChannelInboundHandlerAdapter</span></a><ul class="menu-list"><li><a class="is-flex" href="#ChannelInboundHandler"><span class="mr-2">2.1</span><span>ChannelInboundHandler</span></a></li></ul></li><li><a class="is-flex" href="#SimpleChannelInboundHandler"><span class="mr-2">3</span><span>SimpleChannelInboundHandler</span></a><ul class="menu-list"><li><a class="is-flex" href="#ReferenceCounted"><span class="mr-2">3.1</span><span>ReferenceCounted</span></a></li></ul></li><li><a class="is-flex" href="#ctx-channel-write-和ctx-write-的区别"><span class="mr-2">4</span><span>ctx.channel().write()和ctx.write()的区别</span></a></li><li><a class="is-flex" href="#Java-NIO"><span class="mr-2">5</span><span>Java NIO</span></a><ul class="menu-list"><li><a class="is-flex" href="#NIO-总结"><span class="mr-2">5.1</span><span>NIO 总结</span></a></li><li><a class="is-flex" href="#Java-NIO中，关于DirectBuffer，HeapBuffer的疑问？"><span class="mr-2">5.2</span><span>Java NIO中，关于DirectBuffer，HeapBuffer的疑问？</span></a></li></ul></li><li><a class="is-flex" href="#ByteBuf"><span class="mr-2">6</span><span>ByteBuf</span></a><ul class="menu-list"><li><a class="is-flex" href="#Netty-提供的-3-种缓冲区"><span class="mr-2">6.1</span><span>Netty 提供的 3 种缓冲区</span></a></li><li><a class="is-flex" href="#JDK-的-ByteBuffer-与-Netty-的-ByteBuf-之间的差异比对"><span class="mr-2">6.2</span><span>JDK 的 ByteBuffer 与 Netty 的 ByteBuf 之间的差异比对</span></a></li></ul></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://blog.cuzz.site',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>