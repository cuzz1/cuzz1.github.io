<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>深入理解 synchronized 关键字 - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="深入理解 synchronized 关键字"><meta property="og:url" content="http://blog.cuzz.site/2020/09/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://picsum.photos/509/342"><meta property="article:published_time" content="2020-09-09T15:59:59.000Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="synchronized"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://picsum.photos/509/342"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2020/09/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"},"headline":"cuzz's blog","image":[],"datePublished":"2020-09-09T15:59:59.000Z","author":{"@type":"Person","name":"John Doe"},"description":"如果某一个资源被多个线程共享，为了避免因为资源抢占导致资源数据错乱，我们需要对线程进行同步，那么synchronized就是实现线程同步的关键字，是用来保证被锁定了代码同一时间只能有一个线程执行，那么synchronized关键字的实现原理是怎样的呢？"}</script><link rel="canonical" href="http://blog.cuzz.site/2020/09/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/likes">Likes</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://picsum.photos/509/342" alt="深入理解 synchronized 关键字"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-09-09T15:59:59.000Z" title="2020-09-09T15:59:59.000Z">2020-09-09</time></span><span class="level-item"><a class="link-muted" href="/categories/JAVA/">JAVA</a></span><span class="level-item">an hour read (About 9498 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">深入理解 synchronized 关键字</h1><div class="content"><p>如果某一个资源被多个线程共享，为了避免因为资源抢占导致资源数据错乱，我们需要对线程进行同步，那么synchronized就是实现线程同步的关键字，是用来保证被锁定了代码同一时间只能有一个线程执行，那么synchronized关键字的实现原理是怎样的呢？</p>
<a id="more"></a>

<p>先给出一张图，看看 synchronized 这个关键字有多复杂，先看看能看懂多少，如果看不太懂，希望看完本文能真正理解 synchronized 关键字和这张图。</p>
<p><img src="http://img.cuzz.site/2020/4491294-e3bcefb2bacea224-20200910141026692.png"></p>
<h2 id="synchronized-用法"><a href="#synchronized-用法" class="headerlink" title="synchronized 用法"></a>synchronized 用法</h2><p>synchronized 在用法上可以分为如下四种：普通方法、对象、静态方法和类。</p>
<p>1、普通方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2、对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>4、类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Obj.class) &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们要知道，syncnronized 锁的并不是代码块而是对象，锁静态方法也是锁住这个类。</p>
<h2 id="synchronized-特性"><a href="#synchronized-特性" class="headerlink" title="synchronized 特性"></a>synchronized 特性</h2><ul>
<li><p>原子性</p>
</li>
<li><p>可见性</p>
</li>
<li><p>有序性</p>
</li>
<li><p>可重入性</p>
</li>
</ul>
<h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h2><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><p>通过查看字节码来看看 synchronized 在字节码程度实现。</p>
<p>1、先看看在 synchronized 修饰在方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入到编译后的 classes 目录下，找到对应的类，使用 <code>javap -v XX.class</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void method();</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED &#x2F;&#x2F; 注意这个</span><br><span class="line">   Code:</span><br><span class="line">     stack&#x3D;0, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">        0: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 13: 0</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0       1     0  this   Lcom&#x2F;cuzz&#x2F;syn&#x2F;Test;</span><br></pre></td></tr></table></figure>

<p>我们发现在 flags 上有一个 ACC_SYNCHRONIZED 标识。</p>
<p>2、对象上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果，在字节码成面上有 monitorenter 和 monitorexit，其中后面一个 monitorexit 表示异常退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: (0x0001) ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #3                  </span><br><span class="line">       4: dup</span><br><span class="line">       5: astore_1</span><br><span class="line">       6: monitorenter      &#x2F;&#x2F; ---&gt; 进入</span><br><span class="line">       7: aload_1</span><br><span class="line">       8: monitorexit       &#x2F;&#x2F; ---&gt; 退出</span><br><span class="line">       9: goto          17</span><br><span class="line">      12: astore_2</span><br><span class="line">      13: aload_1</span><br><span class="line">      14: monitorexit       &#x2F;&#x2F; ---&gt; 异常退出</span><br><span class="line">      15: aload_2</span><br><span class="line">      16: athrow</span><br><span class="line">      17: return</span><br></pre></td></tr></table></figure>

<h3 id="montor"><a href="#montor" class="headerlink" title="montor"></a>montor</h3><p>1、monitorenter JVM 规范中描述</p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref,  as follows: </p>
<ul>
<li>If the entry count of the monitor associated with objectref is zero,  the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor. </li>
<li>If the thread already owns the monitor associated with objectref， it reenters the monitor， incrementing its entry count. </li>
<li>If another thread already owns the monitor associated with objectref， the thread blocks until the monitor’s entry count is zero， then tries again to gain ownership.</li>
</ul>
</blockquote>
<p>2、monitorexit JVM 规范中描述</p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref. The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero， the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过 javap 反汇编我们看到 synchronized 使用编程了 monitorentor 和 monitorexit 两个指令：</p>
<ul>
<li>每个锁对象都会关联一个 monitor （监视器它才是真正的锁对象）。</li>
<li>它内部有两个重要的成员变量 owner 会保存获得锁的线程，recursions 会保存线程获得锁的次数。</li>
<li>当执行到 monitorenter 时，recursions 会+1；当执行到 monitorexit 时，recursions会-1，当计数器减到 0 时这个线程就会释放锁。</li>
<li>同步方法在反汇编后，会增加 <code>ACC_SYNCHRONIZED</code> 修饰，会隐式调用 monitorenter 和 monitorexit。在执行同步方法前会调用 monitorenter，在执行完同步方法后会调用 monitorexit。</li>
</ul>
<h2 id="深入-JVM-源码"><a href="#深入-JVM-源码" class="headerlink" title="深入 JVM 源码"></a>深入 JVM 源码</h2><h3 id="monitor-监视锁"><a href="#monitor-监视锁" class="headerlink" title="monitor 监视锁"></a>monitor 监视锁</h3><p>先下载 JVM 源码， <a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk">https://github.com/openjdk/jdk</a> 导入 CLion 中，切到 1.8 tag 上。</p>
<p>在HotSpot虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码是用 C++ 来实现的，位于HotSpot虚 拟机源码 ObjectMonitor.hpp 文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor  主要数据结构如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;         <span class="comment">// 用来记录该对象被线程获取锁的次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;         <span class="comment">// 线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;      <span class="comment">// 储存改monitor的对象</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>;      <span class="comment">// 标识拥有该monitor的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;      <span class="comment">// 处于wait状态的线程，会加入到其中</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;     <span class="comment">// 多线程竞争锁的单向列表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;     <span class="comment">// 处于等待锁block状态的线程，会加入该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键属性解释：</p>
<ul>
<li><code>_owner</code>：初始时为NULL，当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程释放monitor时，owner又恢复为NULL，owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li>
<li><code>_cxq</code>：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链表）。<code>_cxq</code>是一个临界资 源，JVM通过CAS原子指令来修改<code>_cxq</code>队列。修改前<code>_cxq</code>的旧值填入了node的next字段，<code>_cxq</code>指向新值(新线程)。因此<code>_cxq</code>是一个后进先出的栈。</li>
<li><code>_EntryList</code>：<code>_cxq</code>队列中有资格成为候选资源的线程会被移动到该队列中。</li>
<li><code>_WaitSet</code>：因为调用wait方法而被阻塞的线程会被放在该队列中。</li>
</ul>
<p>具体过程：</p>
<ul>
<li>当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于blocking状态</li>
<li>当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，此时，ObjectMonitor对象_owner指向当前线程，_count加1表示当前对象锁被一个线程获取</li>
<li>当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，同时线程进入_WaitSet队列，直到有线程调用notify()方法唤醒该线程，则该线程重新获取monitor对象进入_Owner区</li>
<li>如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为 null</li>
</ul>
<p>ObjectMonitor 的数据结构中包含：_owner、_WaitSet 和 _EntryList，它们之间的关系转换可以用下图表示:</p>
<center><img src="http://img.cuzz.site/20200912140215.jpeg"></center>

<p>每一个 Java 对象都可以与一个监视器 monitor 关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被 synchronized 圈起来的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的monitor。</p>
<p>我们的 Java 代码里不会显示地去创造这么一个monitor对象，我们也无需创建，事实上可以这么理解：</p>
<ul>
<li>monitor并不是随着对象创建而创建的。</li>
<li>我们是通过synchronized修饰符告诉 JVM 需要为我们的某个对象创建关联的monitor对象。</li>
<li>每个线程都存在两个ObjectMonitor 对象列表，分别为free和used列表。 同时JVM中也维护着global locklist。</li>
<li>当线程需要ObjectMonitor对象时，首先从线程自身的free表中申请，若存在则使用，若不存在则从global list中申请。</li>
</ul>
<h3 id="monitor-竞争"><a href="#monitor-竞争" class="headerlink" title="monitor 竞争"></a>monitor 竞争</h3><p>在字节码上 monitorenter，最终会调用 InterpreterRuntime.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="comment">// 是否使用偏向锁</span></span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<p>最终调用 ObjectMonitor::enter 方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">  <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line">  <span class="comment">// _owner为NULL表示无锁</span></span><br><span class="line">  <span class="comment">// 通过CAS操作吧monitor的_owner字段设置为当前线程</span></span><br><span class="line">  <span class="comment">// 这个会根据不同的操作系统有不同的实现如果是Linux，则在atomic_linux_x86.inline.hpp中</span></span><br><span class="line">  <span class="comment">// 返回旧值</span></span><br><span class="line">  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="comment">// 设置成功</span></span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span></span><br><span class="line">     assert (_recursions == <span class="number">0</span>   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     assert (_owner      == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 线程重入，_recursions++</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果当前线程是第一次进入该monitor,设置_recursions为1，_owner为当前线程</span></span><br><span class="line">  <span class="comment">// 当前线程是之前持有轻量级锁的线程。由轻量级锁膨胀且第一次调用enter方法，那cur是指向Lock Record的指针</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">    assert (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">    <span class="comment">// a full-fledged &quot;Thread *&quot;.</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在调用系统的同步操作之前，先尝试自旋获得锁</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//自旋的过程中获得了锁，则直接返回</span></span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过自旋执行ObjectMonitor::EnterI方法等待锁的释放</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;set_suspend_equivalent();</span><br><span class="line">      <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">      <span class="comment">// or java_suspend_self()</span></span><br><span class="line">      EnterI (THREAD) ;</span><br><span class="line">      <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We have acquired the contended monitor, but while we were</span></span><br><span class="line">      <span class="comment">// waiting another thread suspended us. We don&#x27;t want to enter</span></span><br><span class="line">      <span class="comment">// the monitor while suspended because that would surprise the</span></span><br><span class="line">      <span class="comment">// thread that suspended us.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">          _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="built_in">exit</span> (Self) ;</span><br><span class="line">      jt-&gt;java_suspend_self();</span><br><span class="line">    &#125;</span><br><span class="line">  Self-&gt;set_current_pending_monitor(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码具体逻辑：</p>
<ul>
<li>通过CAS尝试吧monItor的_owner设置为当前线程</li>
<li>如果设置之前的_owner指向当前线程，说明线程再次进入monitor，为重入锁，_recursions++，记录重入得次数</li>
<li>如果当前线程是第一次进入monitor，设置_recursions为1，_owner为当前线程，改线程获得锁</li>
<li>如果获得锁失败，则等待锁的释放</li>
</ul>
<h3 id="monitor-等待"><a href="#monitor-等待" class="headerlink" title="monitor 等待"></a>monitor 等待</h3><p>竞争失败等待调用的是ObjectMonitor对象的EnterI方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 尝试获得锁</span></span><br><span class="line">    <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DeferredInitialize () ;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">if</span> (TrySpin (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将线程封装成node节点中</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将node节点插入到_cxq队列的头部，cxq是一个单向链表</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS失败的话 再尝试获得锁，这样可以降低插入到_cxq队列的频率</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SyncFlags默认为0，如果没有其他等待的线程，则将_Responsible设置为自己</span></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TEVENT (Inflated enter - Contention) ;</span><br><span class="line">    <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 线程在被挂起前再尝试一次，看能不能获得到锁</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        assert (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 当前线程是_Responsible时，调用的是带时间参数的park</span></span><br><span class="line">            TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则直接调用park挂起当前线程</span></span><br><span class="line">            TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; TrySpin (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 在释放锁时，_succ会被设置为EntryList或_cxq中的一个线程</span></span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::fence() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 走到这里说明已经获得锁了</span></span><br><span class="line"></span><br><span class="line">    assert (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    assert (object() != <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将当前线程的node从cxq或EntryList中移除</span></span><br><span class="line">    UnlinkAfterAcquire (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::fence();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程被唤醒时，会从挂起点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">void</span> * own = _owner ;</span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">if</span> (Atomic::cmpxchg_ptr (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">         assert (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         assert (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The lock had been free momentarily, but we lost the race to the lock.</span></span><br><span class="line">      <span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line">      <span class="comment">// We can either return -1 or retry.</span></span><br><span class="line">      <span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码具体流程：</p>
<ul>
<li>将当前线程插入到cxq队列的队首</li>
<li>然后park当前线程</li>
<li>当被唤醒后再尝试获得锁</li>
</ul>
<h3 id="monitor-释放"><a href="#monitor-释放" class="headerlink" title="monitor 释放"></a>monitor 释放</h3><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在 HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于 ObjectMonitor的exit方法中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">       </span><br><span class="line">   <span class="comment">// 看看_recursions 是否为0</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">     TEVENT (Inflated <span class="built_in">exit</span> - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invariant: after setting Responsible=null an thread must execute</span></span><br><span class="line">   <span class="comment">// a MEMBAR or other serializing instruction before fetching EntryList|cxq.</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      assert (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      guarantee (_owner == THREAD, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="keyword">int</span> QMode = Knob_QMode ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// QMode = 2:直接绕过EntryList队列，从_cxq队列中获取线程用于竞争锁</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          w = _cxq ;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          assert (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Qmode = 3: _cxq队列插入EntryList尾部</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Append the RATs to the EntryList</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span></span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Qmode = 4: _cxq队列插入EntryList头部</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Prepend the RATs to the EntryList</span></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          _EntryList = w ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        </span><br><span class="line">          assert (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we find that both _cxq and EntryList are null then just</span></span><br><span class="line">      <span class="comment">// re-run the exit protocol from the top.</span></span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">      <span class="comment">// First, detach _cxq.</span></span><br><span class="line">      <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line">      TEVENT (Inflated <span class="built_in">exit</span> - drain cxq into EntryList) ;</span><br><span class="line"></span><br><span class="line">      assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      assert (_EntryList  == <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// QMode = 1 : 将_cxq中的元素转移到EntryList，并反转顺序</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : drain cxq to EntryList, reversing order</span></span><br><span class="line">         <span class="comment">// We also reverse the order of the list.</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         assert (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL</span></span><br><span class="line">      <span class="comment">// The MEMBAR is satisfied by the release_store() operation in ExitEpilog().</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// See if we can abdicate to a spinner instead of waking a thread.</span></span><br><span class="line">      <span class="comment">// A primary goal of the implementation is to reduce the</span></span><br><span class="line">      <span class="comment">// context-switch rate.</span></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。 </p>
<p>根据不同的策略(由QMode指定)，从cxq或EntryList中获取头节点，通过<br>ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由unpark完成，实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>&#123;</span><br><span class="line">   assert (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exit protocol:</span></span><br><span class="line">   <span class="comment">// 1. ST _succ = wakee</span></span><br><span class="line">   <span class="comment">// 2. membar #loadstore|#storestore;</span></span><br><span class="line">   <span class="comment">// 2. ST _owner = NULL</span></span><br><span class="line">   <span class="comment">// 3. unpark(wakee)</span></span><br><span class="line"></span><br><span class="line">   _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : <span class="literal">NULL</span> ;</span><br><span class="line">   ParkEvent * Trigger = Wakee-&gt;_event ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Hygiene -- once we&#x27;ve set _owner = NULL we can&#x27;t safely dereference Wakee again.</span></span><br><span class="line">   <span class="comment">// The thread associated with Wakee may have grabbed the lock and &quot;Wakee&quot; may be</span></span><br><span class="line">   <span class="comment">// out-of-scope (non-extant).</span></span><br><span class="line">   Wakee  = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Drop the lock</span></span><br><span class="line">   OrderAccess::release_store_ptr (&amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">   OrderAccess::fence() ;                               <span class="comment">// ST _owner vs LD in unpark()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SafepointSynchronize::do_call_back()) &#123;</span><br><span class="line">      TEVENT (unpark before SAFEPOINT) ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   DTRACE_MONITOR_PROBE(contended__exit, <span class="keyword">this</span>, object(), Self);</span><br><span class="line">   <span class="comment">// 唤醒之前被pack()挂起的线程</span></span><br><span class="line">   Trigger-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Maintain stats and report events to JVMTI</span></span><br><span class="line">   <span class="keyword">if</span> (ObjectMonitor::_sync_Parks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ObjectMonitor::_sync_Parks-&gt;inc() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 被唤醒的线程，会回到EnterI方法中的继续执行monitor的竞争。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">    assert (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// park self</span></span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">        Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line">        <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">        RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">        <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">        Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h3><p>可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数， 执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就 会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语 言中是一个重量级(Heavyweight)的操作。</p>
<p>用户态和和内核态是什么东西呢?要想了解用户态和内核态还需要先了解一下Linux系统的体系架构:</p>
<center><img src="http://img.cuzz.site/20200913001532.jpeg" width="200px"></center> 

<p>从上图可以看出，Linux操作系统的体系架构分为:用户空间(应用程序的活动空间)和内核。 </p>
<ul>
<li>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</li>
<li>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存 储资源、I/O资源等。</li>
<li>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口:即系统调用。</li>
</ul>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态(简称:用户态);但是当它调用系统调用执行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态(或简称为内 核态)。 系统调用的过程可以简单理解为：</p>
<ol>
<li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提 供的服务。</li>
<li>用户态程序执行系统调用。</li>
<li>CPU切换到内核态，并跳到位于内存指定位置的指令。</li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。</li>
<li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。<br>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器 值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在 synchronized未优化之前，效率低的原因。</li>
</ol>
<h2 id="JVM-对-synchronzied-底层优化"><a href="#JVM-对-synchronzied-底层优化" class="headerlink" title="JVM 对 synchronzied 底层优化"></a>JVM 对 synchronzied 底层优化</h2><p>高效并发是从JDK 5到JDK 6的一个重要改进，HotSpot虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为 了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p>
<p>具体源码分析推荐看这几篇文章：<a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现</a></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 全称是 compare and swap，是一种用于在多线程环境下实现同步功能的机制。CAS 操作包含三个操作数：内存位置、预期数值和新值。CAS 的实现逻辑是将内存位置处的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。</p>
<p>在 Java 中，Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，Java 代码需通过 JNI 才能调用。</p>
<p>CAS实现并发，我们先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                atomicInteger.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(atomicInteger.get()); <span class="comment">// 输出 10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层是调用 jdk.internal.misc.Unsafe#getAndAddInt 这个方法</p>
<h3 id="JAVA对象布局"><a href="#JAVA对象布局" class="headerlink" title="JAVA对象布局"></a>JAVA对象布局</h3><p>当一个线程尝试访问 synchronized 修饰的代码块时，它首先要获得锁，那么 这个锁到底存在哪里呢？</p>
<p>是存在锁对象的对象头里。</p>
<p>java对象布局 JOL（java object layout）描述对象在堆内存的布局，如图所示：</p>
<center><img src="http://img.cuzz.site/20200913223318.png" width="500px"></center>

<ul>
<li>markword： 固定长度8字节，描述对象的 identityhashcode、GC分代年龄、锁的状态标志、线程持有的锁、偏向锁的线程ID和偏向时间戳等等；</li>
<li>klasspoint： 固定长度4字节, 指定该对象的class类对象（默认使用-XX:+UseCompressedClassPointers 参数进行压缩，可使用-XX:-UseCompressedClassPointers关闭，则该字段在64位jvm下占用8个字节；可使用java -XX:+PrintCommandLineFlags -version 命令查看默认的或已设置的jvm参数）；</li>
<li>基本变量：用于存放java八种基本类型成员变量，以4字节步长进行补齐，使用内存重排序优化空间；</li>
<li>引用变量：存放对象地址，如String，Object；占用4个字节，64位jvm上默认使用-XX:+UseCompressedOops进行压缩，可使用-XX:-UseCompressedOops进行关闭，则在64位jvm上会占用8个字节；</li>
<li>补齐：对象大小必须是8字节的整数倍，用来补齐字节数。Object o = new Object() 在内存中占用16个字节，其中最后4个是补齐；</li>
<li>数组长度：如果是数组，额外占用固定4字节存放数组长度；</li>
</ul>
<p>jol-core 是 openjdk的一个工具，他可以很方便的让我看到一个对象的布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们查看一下对象和数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(arr).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[I object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           10 0c 00 00 (00010000 00001100 00000000 00000000) (3088)</span><br><span class="line">     12     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">     16     4    int [I.&lt;elements&gt;                             N&#x2F;A</span><br><span class="line">     20     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p>HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类 型。instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc 的定义对应 arrayOop.hpp 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">instanceOopDesc</span> :</span> <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// aligned header size.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">header_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If compressed, the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UseCompressedOops ?</span><br><span class="line">             klass_gap_offset_in_bytes() :</span><br><span class="line">             <span class="keyword">sizeof</span>(instanceOopDesc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> nonstatic_field_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base_in_bytes = base_offset_in_bytes();</span><br><span class="line">    <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp;</span><br><span class="line">            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot 源码中的 oop.hpp 文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMStructs</span>;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop  _mark;</span><br><span class="line">  <span class="keyword">union</span> _metadata &#123;</span><br><span class="line">    wideKlassOop    _klass;</span><br><span class="line">    narrowOop       _compressed_klass;</span><br><span class="line">  &#125; _metadata;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark 和 _metadata。</li>
<li>_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息。</li>
<li>_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示普通指针、 _compressed_klass 表示压缩类指针。</li>
<li>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指针，及对象指向它的类元数据的指针。</li>
</ul>
<p>我们看一下markOop.hpp 中对的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  64 bits:</span><br><span class="line">&#x2F;&#x2F;  --------</span><br><span class="line">&#x2F;&#x2F;  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span><br><span class="line">&#x2F;&#x2F;  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span><br><span class="line">&#x2F;&#x2F;  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="line">&#x2F;&#x2F;  size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span><br><span class="line">&#x2F;&#x2F;  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span><br><span class="line">&#x2F;&#x2F;  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span><br><span class="line">&#x2F;&#x2F;  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  - hash contains the identity hash value: largest value is</span><br><span class="line">&#x2F;&#x2F;    31 bits, see os::random().  Also, 64-bit vm&#39;s require</span><br><span class="line">&#x2F;&#x2F;    a hash value no bigger than 32 bits because they will not</span><br><span class="line">&#x2F;&#x2F;    properly generate a mask larger than that: see library_call.cpp</span><br><span class="line">&#x2F;&#x2F;    and c1_CodePatterns_sparc.cpp.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  - the biased lock pattern is used to bias a lock toward a given</span><br><span class="line">&#x2F;&#x2F;    thread. When this pattern is set in the low three bits, the lock</span><br><span class="line">&#x2F;&#x2F;    is either biased toward a given thread or &quot;anonymously&quot; biased,</span><br><span class="line">&#x2F;&#x2F;    indicating that it is possible for it to be biased. When the</span><br><span class="line">&#x2F;&#x2F;    lock is biased toward a given thread, locking and unlocking can</span><br><span class="line">&#x2F;&#x2F;    be performed by that thread without using atomic operations.</span><br><span class="line">&#x2F;&#x2F;    When a lock&#39;s bias is revoked, it reverts back to the normal</span><br><span class="line">&#x2F;&#x2F;    locking scheme described below.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    Note that we are overloading the meaning of the &quot;unlocked&quot; state</span><br><span class="line">&#x2F;&#x2F;    of the header. Because we steal a bit from the age we can</span><br><span class="line">&#x2F;&#x2F;    guarantee that the bias pattern will never be seen for a truly</span><br><span class="line">&#x2F;&#x2F;    unlocked object.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    Note also that the biased state contains the age bits normally</span><br><span class="line">&#x2F;&#x2F;    contained in the object header. Large increases in scavenge</span><br><span class="line">&#x2F;&#x2F;    times were seen when these bits were absent and an arbitrary age</span><br><span class="line">&#x2F;&#x2F;    assigned to all biased objects, because they tended to consume a</span><br><span class="line">&#x2F;&#x2F;    significant fraction of the eden semispaces and were not</span><br><span class="line">&#x2F;&#x2F;    promoted promptly, causing an increase in the amount of copying</span><br><span class="line">&#x2F;&#x2F;    performed. The runtime system aligns all JavaThread* pointers to</span><br><span class="line">&#x2F;&#x2F;    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))</span><br><span class="line">&#x2F;&#x2F;    to make room for the age bits &amp; the epoch bits (used in support of</span><br><span class="line">&#x2F;&#x2F;    biased locking), and for the CMS &quot;freeness&quot; bit in the 64bVM (+COOPs).</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span><br><span class="line">&#x2F;&#x2F;    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  - the two lock bits are used to describe three states: locked&#x2F;unlocked and monitor.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    [ptr             | 00]  locked             ptr points to real header on stack</span><br><span class="line">&#x2F;&#x2F;    [header      | 0 | 01]  unlocked           regular object header</span><br><span class="line">&#x2F;&#x2F;    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span><br><span class="line">&#x2F;&#x2F;    [ptr             | 11]  marked             used by markSweep to mark an object</span><br><span class="line">&#x2F;&#x2F;                                               not valid at any other time</span><br></pre></td></tr></table></figure>

<p>根据下面图理解</p>
<center><img src="http://img.cuzz.site/20200914123608.jpeg"></center>

<p>以及</p>
<center><img src="http://img.cuzz.site/20200914104714.jpeg"></center>

<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>先打印一下，如果我们不调用 hashCode 在markword上是不会显示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(Integer.toHexString(o.hashCode()));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hashCode: 2d209079</span><br><span class="line"></span><br><span class="line">OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 79 90 20 (00000001 01111001 10010000 00100000) (546339073)</span><br><span class="line">      4     4        (object header)                           2d 00 00 00 (00101101 00000000 00000000 00000000) (45)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br></pre></td></tr></table></figure>

<p>x86都是使用的小端模式，我们转为大端显示更直观一些</p>
<ul>
<li>我们看最后三位为 001 表示无锁。</li>
<li>其中 hashCode [0 00101101 00100000 10010000 01111001]转换类 16 进制为 0x2d209079。</li>
<li>分代年龄为 4 位，说明 JVM 回收最大存活为 15 代。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小端 00000001 01111001 10010000 00100000 00101101 00000000 00000000 00000000</span><br><span class="line">大端 00000000 00000000 00000000 00101101 00100000 10010000 01111001 00000001</span><br><span class="line"></span><br><span class="line">[00000000 00000000 0000000][0 00101101 00100000 10010000 01111001] [0][0000][0][01] </span><br><span class="line">        未使用                           hashCode               cms_free 分代年龄 偏向锁 锁标志</span><br></pre></td></tr></table></figure>

<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及 ThreadID 即可。</p>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操 作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每 次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
<p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以 提高带有同步但无竞争的程序性能。</p>
<p>偏向锁在Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活（因为刚启动程序内部一般会有多个竞争），当然可以使用<code>-XX:BiasedLockingStartupDelay=0</code>参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 <code>-XX:UseBiasedLocking=false</code>参数关闭偏向锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待虚拟机开启偏向锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 a0 00 a6 (00000101 10100000 00000000 10100110) (-1509908475)</span><br><span class="line">      4     4        (object header)                           bb 7f 00 00 (10111011 01111111 00000000 00000000) (32699)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p>第一次打印为匿名偏向，第二次偏向锁指向了main 线程，第一个线程ID为0，第二有线程ID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">匿名偏向：</span><br><span class="line">小端 00000101 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">大端 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101</span><br><span class="line"></span><br><span class="line">[00000000 00000000 00000000 00000000 00000000 00000000 000000][00] [00000][1][01]</span><br><span class="line">                         线程ID                         偏向时间戳 cms_free 分代年龄 偏向锁 锁标志</span><br><span class="line"></span><br><span class="line">偏向main线程：</span><br><span class="line">小端 00000101 10100000 00000000 10100110 10111011 01111111 00000000 00000000</span><br><span class="line">大端 00000000 00000000 01111111 10111011 10100110 00000000 10100000 00000101</span><br><span class="line"></span><br><span class="line">[00000000 00000000 01111111 10111011 10100110 00000000 101000][00] [0][0000][1][01]</span><br><span class="line">                          线程ID                         偏向时间戳 cms_free 分代年龄 偏向锁 锁标志</span><br></pre></td></tr></table></figure>

<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是JDK 6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用monitor的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p>
<p>引入轻量级锁的目的：<strong>在多线程交替执行同步块的情况下</strong>，尽量避免重量级锁引起的性能消耗，但是如 果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要 替代重量级锁。</p>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下:</p>
<ul>
<li>判断当前对象是否处于无锁状态，如果是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），将对象的 Mark Word 复制到栈帧中的 Lock Record 中，将 Lock Reocrd 中的 owner 指向当前对象。</li>
<li>JVM利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，如果成功表示竞争到锁，则将锁标志位变成 00，执行同步操作。</li>
<li>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻 量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。</li>
</ul>
<p>轻量级锁CAS操作之前堆栈与对象的状态</p>
<center><img src="http://img.cuzz.site/20200914204159.png" width="500px"></center>

<p>轻量级锁CAS操作之后堆栈与对象的状态</p>
<center><img src="http://img.cuzz.site/20200914204552.png" width="360px"></center>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待虚拟机开启偏向锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 c8 00 2f (00000101 11001000 00000000 00101111) (788580357)</span><br><span class="line">      4     4        (object header)                           d7 7f 00 00 (11010111 01111111 00000000 00000000) (32727)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           00 5a a9 03 (00000000 01011010 10101001 00000011) (61430272)</span><br><span class="line">      4     4        (object header)                           00 70 00 00 (00000000 01110000 00000000 00000000) (28672)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<p>发现从偏向锁转为轻量级锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">偏向锁：</span><br><span class="line">大端 00000101 11001000 00000000 00101111 11010111 01111111 00000000 00000000</span><br><span class="line">小端 00000000 00000000 01111111 11010111 00101111 00000000 11001000 00000101</span><br><span class="line"></span><br><span class="line">轻量级锁：</span><br><span class="line">大端 00000000 01011010 10101001 00000011 00000000 01110000 00000000 00000000</span><br><span class="line">小端 00000000 00000000 01110000 00000000 00000011 10101001 01011010 00000000</span><br><span class="line"></span><br><span class="line">[00000000 00000000 01110000 00000000 00000011 10101001 01011010 000000][00]</span><br><span class="line">                  指向轻量级锁指针                                        锁标志</span><br></pre></td></tr></table></figure>

<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等待虚拟机开启偏向锁</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展示了从偏向锁（101）-&gt; 轻量级锁（000）-&gt; 重量级锁（010）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 90 80 33 (00000101 10010000 10000000 00110011) (864063493)</span><br><span class="line">      4     4        (object header)                           fc 7f 00 00 (11111100 01111111 00000000 00000000) (32764)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           00 3a d6 06 (00000000 00111010 11010110 00000110) (114702848)</span><br><span class="line">      4     4        (object header)                           00 70 00 00 (00000000 01110000 00000000 00000000) (28672)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           02 3f 21 33 (00000010 00111111 00100001 00110011) (857816834)</span><br><span class="line">      4     4        (object header)                           fc 7f 00 00 (11111100 01111111 00000000 00000000) (32764)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           02 3f 21 33 (00000010 00111111 00100001 00110011) (857816834)</span><br><span class="line">      4     4        (object header)                           fc 7f 00 00 (11111100 01111111 00000000 00000000) (32764)</span><br><span class="line">      8     4        (object header)                           00 10 00 00 (00000000 00010000 00000000 00000000) (4096)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external &#x3D; 4 bytes total</span><br></pre></td></tr></table></figure>

<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>自旋锁：许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行循环等待锁的释放，不让出CPU。如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式。但是它也存在缺点：如果锁被其他线程长时间占用，一直不释放CPU，会带来许多的性能开销。</p>
<p>自适应自旋锁：这种相当于是对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译器(JIT)在运行时，对一些代码上要求同步，但是被检测到不可能存在共享 数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中， 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们 是线程私有的，同步加锁自然就无须进行。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确 定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有 许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上 都没有同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        contactString(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">contactString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().append(s1).append(s2).append(s3).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer的append ( ) 是一个同步方法，锁就是this也就是(new StringBuilder())。虚拟机发现它的 动态作用域被限制在concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃 逸”到concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除 掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作 用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线 程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对 象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操 作也会导致不必要的性能损耗。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大， 放到这串操作的外面，这样只需要加一次锁即可。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>我看很很多视频和文章整理出来的比较，synchronized比较难，涉及到的知识特别多，包括并发、字节码、JVM、汇编以及计算机系统等。在 Java 1.6 以后 JVM 对 synchronized 进行了优化，存在偏向锁、轻量级锁和重量级锁等形式，尤其是锁的锁的升级和降级比较复杂，现在我们回过头再看看这张图，就很容易看懂了。</p>
<p><img src="http://img.cuzz.site/2020/4491294-e3bcefb2bacea224-20200910141026692.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aJ411V763?from=search&seid=11835560625013508239">Java面试热点问题，synchronized原理剖析与优化</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/katsu2017/p/12617098.html">Java对象布局</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lagou.com/lgeduarticle/98007.html">深入理解 Java 虚拟机之对象的内存布局</a></li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/synchronized/">synchronized</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/09/29/Spring%E7%9A%84%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Spring 的复杂类型注入</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/08/26/Dubbo_SPI%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-item">Dubbo SPI源码分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "0e88feec13264163261d6d771b817962",
            repo: "cuzz1.github.io",
            owner: "cuzz1",
            clientID: "e829281603f9115c572d",
            clientSecret: "246dae10dfb1b363805ab98902dc93539c355bb3",
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#synchronized-用法"><span class="mr-2">1</span><span>synchronized 用法</span></a></li><li><a class="is-flex" href="#synchronized-特性"><span class="mr-2">2</span><span>synchronized 特性</span></a></li><li><a class="is-flex" href="#synchronized-实现原理"><span class="mr-2">3</span><span>synchronized 实现原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#字节码"><span class="mr-2">3.1</span><span>字节码</span></a></li><li><a class="is-flex" href="#montor"><span class="mr-2">3.2</span><span>montor</span></a></li><li><a class="is-flex" href="#小结"><span class="mr-2">3.3</span><span>小结</span></a></li></ul></li><li><a class="is-flex" href="#深入-JVM-源码"><span class="mr-2">4</span><span>深入 JVM 源码</span></a><ul class="menu-list"><li><a class="is-flex" href="#monitor-监视锁"><span class="mr-2">4.1</span><span>monitor 监视锁</span></a></li><li><a class="is-flex" href="#monitor-竞争"><span class="mr-2">4.2</span><span>monitor 竞争</span></a></li><li><a class="is-flex" href="#monitor-等待"><span class="mr-2">4.3</span><span>monitor 等待</span></a></li><li><a class="is-flex" href="#monitor-释放"><span class="mr-2">4.4</span><span>monitor 释放</span></a></li><li><a class="is-flex" href="#monitor是重量级锁"><span class="mr-2">4.5</span><span>monitor是重量级锁</span></a></li></ul></li><li><a class="is-flex" href="#JVM-对-synchronzied-底层优化"><span class="mr-2">5</span><span>JVM 对 synchronzied 底层优化</span></a><ul class="menu-list"><li><a class="is-flex" href="#CAS"><span class="mr-2">5.1</span><span>CAS</span></a></li><li><a class="is-flex" href="#JAVA对象布局"><span class="mr-2">5.2</span><span>JAVA对象布局</span></a></li><li><a class="is-flex" href="#无锁"><span class="mr-2">5.3</span><span>无锁</span></a></li><li><a class="is-flex" href="#偏向锁"><span class="mr-2">5.4</span><span>偏向锁</span></a></li><li><a class="is-flex" href="#轻量级锁"><span class="mr-2">5.5</span><span>轻量级锁</span></a></li><li><a class="is-flex" href="#重量级锁"><span class="mr-2">5.6</span><span>重量级锁</span></a></li><li><a class="is-flex" href="#自旋锁"><span class="mr-2">5.7</span><span>自旋锁</span></a></li><li><a class="is-flex" href="#锁消除"><span class="mr-2">5.8</span><span>锁消除</span></a></li><li><a class="is-flex" href="#锁粗化"><span class="mr-2">5.9</span><span>锁粗化</span></a></li></ul></li><li><a class="is-flex" href="#写在最后"><span class="mr-2">6</span><span>写在最后</span></a></li><li><a class="is-flex" href="#参考"><span class="mr-2">7</span><span>参考</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>