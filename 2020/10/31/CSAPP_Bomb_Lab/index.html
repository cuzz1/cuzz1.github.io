<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Bomb Lab - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="Bomb Lab"><meta property="og:url" content="http://blog.cuzz.site/2020/10/31/CSAPP_Bomb_Lab/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://picsum.photos/528/355"><meta property="article:published_time" content="2020-10-31T15:59:59.000Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="汇编"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://picsum.photos/528/355"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2020/10/31/CSAPP_Bomb_Lab/"},"headline":"cuzz's blog","image":[],"datePublished":"2020-10-31T15:59:59.000Z","author":{"@type":"Person","name":"John Doe"},"description":"介绍邪恶博士在我们的班级机器上植入了许多“二进制炸弹”。二进制炸弹是一个由一系列阶段组成的程序。每个阶段都要求你在 stdin 上输入入特定的字符串。如果你输入正确的字符串，则该阶段将被消除，炸弹将进入下一个阶段。否则，炸弹通过打印“ BOOM !!!”而爆炸。然后终止。当每个阶段都已消除时，炸弹便已消除。"}</script><link rel="canonical" href="http://blog.cuzz.site/2020/10/31/CSAPP_Bomb_Lab/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/likes">Likes</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://picsum.photos/528/355" alt="Bomb Lab"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-10-31T15:59:59.000Z" title="2020-10-31T15:59:59.000Z">2020-10-31</time></span><span class="level-item"><a class="link-muted" href="/categories/CSAPP/">CSAPP</a></span><span class="level-item">33 minutes read (About 4881 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Bomb Lab</h1><div class="content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>邪恶博士在我们的班级机器上植入了许多“二进制炸弹”。二进制炸弹是一个由一系列阶段组成的程序。每个阶段都要求你在 stdin 上输入入特定的字符串。如果你输入正确的字符串，则该阶段将被消除，炸弹将进入下一个阶段。否则，炸弹通过打印“ BOOM !!!”而爆炸。然后终止。当每个阶段都已消除时，炸弹便已消除。</p>
<a id="more"></a>

<h3 id="获取炸弹"><a href="#获取炸弹" class="headerlink" title="获取炸弹"></a>获取炸弹</h3><p>进入官网下载 <a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/bomb.tar">bomb.tar</a>  文件，通过 <code>tar -xvf bomb.tar</code> 解压，会得到 3 个文件。</p>
<ul>
<li>README</li>
<li>bomb：可执行二进制炸弹</li>
<li>bomb.c：源文件包含炸弹的主要程序以及引导程序</li>
</ul>
<p>一共有 6 个阶段，前 4 个阶段每个 10 分，后面两个比较难每个 15 分，在拆炸弹的过程中，每次引爆一次会从总分里扣 0.5 分（最多扣 20 分）。</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>有一些小提示需要注意:</p>
<ul>
<li><p>为了防止引爆炸弹，需要学会设置断点，在“炸弹”之前设置断点，防止爆炸</p>
</li>
<li><p>反编译出来的汇编代码很长，并不需要搞懂每行，通过 debugger 观察程序执行变化，根据这些信息去拆除炸弹</p>
</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><code>gdb</code>：命令行调试器，可以一行行地追踪程序，设置断点，查看寄存器和内存</li>
<li><code>objdump -t</code>：输出炸弹程序的符号表。符号表里包含了所有函数和全局变量的名字</li>
<li><code>ojbdump -d</code> ：反编译二进制文件，输出汇编代码</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>汇编知识：<a href="http://blog.cuzz.site/2020/10/20/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/">汇编入门</a></li>
<li>gdb 知识<ul>
<li><code>gdb bomb</code> 进入调试状态</li>
<li><code>run</code> 运行</li>
<li><code>break phase_1</code> 打断点</li>
<li><code>next</code> 简写 <code>n</code> 表示下一行代码 C 语言代码</li>
<li><code>nexti</code> 简写 <code>ni</code> 表示下一行汇编代码</li>
<li><code>continue</code> 简写 <code>c</code> 表示下一个断点</li>
<li><code>disas</code> 显示汇编</li>
<li><code>info registers</code> 查看寄存器的值</li>
<li><code>x/s $rax</code>  以字符串形式查看</li>
</ul>
</li>
</ul>
<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>在命令行中反编译可执行文件，输入到 <code>bomb.txt</code> 文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.txt</span><br></pre></td></tr></table></figure>

<p>我们先看一下 main 函数，一共 6 个阶段，每个阶段都是一个 <code>phase_x</code> 的函数，在函数正常结束之后运行<code>phase_defused</code>拆除这个阶段，然后进入下一阶段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e19:   e8 84 05 00 00          callq  4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">400e1e:   bf 38 23 40 00          mov    $0x402338,%edi</span><br><span class="line">400e23:   e8 e8 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e28:   bf 78 23 40 00          mov    $0x402378,%edi</span><br><span class="line">400e2d:   e8 de fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e32:   e8 67 06 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">400e37:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">400e3a:   e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:   e8 80 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:   bf a8 23 40 00          mov    $0x4023a8,%edi</span><br><span class="line">400e49:   e8 c2 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e4e:   e8 4b 06 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">400e53:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">400e56:   e8 a1 00 00 00          callq  400efc &lt;phase_2&gt;</span><br><span class="line">400e5b:   e8 64 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e60:   bf ed 22 40 00          mov    $0x4022ed,%edi</span><br><span class="line">400e65:   e8 a6 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e6a:   e8 2f 06 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">400e6f:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">400e72:   e8 cc 00 00 00          callq  400f43 &lt;phase_3&gt;</span><br><span class="line">400e77:   e8 48 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e7c:   bf 0b 23 40 00          mov    $0x40230b,%edi</span><br><span class="line">400e81:   e8 8a fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e86:   e8 13 06 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">400e8b:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">400e8e:   e8 79 01 00 00          callq  40100c &lt;phase_4&gt;</span><br><span class="line">400e93:   e8 2c 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e98:   bf d8 23 40 00          mov    $0x4023d8,%edi</span><br><span class="line">400e9d:   e8 6e fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400ea2:   e8 f7 05 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">400ea7:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">400eaa:   e8 b3 01 00 00          callq  401062 &lt;phase_5&gt;</span><br><span class="line">400eaf:   e8 10 07 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400eb4:   bf 1a 23 40 00          mov    $0x40231a,%edi</span><br><span class="line">400eb9:   e8 52 fc ff ff          callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400ebe:   e8 db 05 00 00          callq  40149e &lt;read_line&gt;</span><br><span class="line">400ec3:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">400ec6:   e8 29 02 00 00          callq  4010f4 &lt;phase_6&gt;</span><br><span class="line">400ecb:   e8 f4 06 00 00          callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>

<h3 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h3><p>我们从上面我们可以看到调用了 <code>phase_1</code> 函数，找到对应的汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">  400e32:   e8 67 06 00 00          callq  40149e &lt;read_line&gt; # 获取stdin输入的值</span><br><span class="line">  400e37:   48 89 c7                mov    %rax,%rdi          # 把输入值保存到 %rdi 寄存器中</span><br><span class="line">  400e3a:   e8 a1 00 00 00          callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">  ... </span><br><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:       48 83 ec 08             sub    $0x8,%rsp # 压栈</span><br><span class="line">  400ee4:       be 00 24 40 00          mov    $0x402400,%esi # 把$0x402400的地址保存%rsi中，%esi就%rsi的低位</span><br><span class="line">  400ee9:       e8 4a 04 00 00          callq  401338 &lt;strings_not_equal&gt; # 比较%rdi和%rsi的值，是否不相同,%rdi是我们输入的。如果不相同返回1，相同返回0</span><br><span class="line">  400eee:       85 c0                   test   %eax,%eax # test a,b &#x3D;&gt; b&amp;a，结果只保存在%rax中</span><br><span class="line">  400ef0:       74 05                   je     400ef7 &lt;phase_1+0x17&gt; # 如果%rax为0则跳转</span><br><span class="line">  400ef2:       e8 43 05 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:       48 83 c4 08             add    $0x8,%rsp</span><br><span class="line">  400efb:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>上面分析的很清楚了，我们开始拆吧，在终端输入 <code>gdb bomb</code> 进入调试模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;(gdb) break phase_1 # 打断点</span><br><span class="line">Breakpoint 1 at 0x400ee0</span><br><span class="line">&gt;(gdb) break explode_bomb # 打断点</span><br><span class="line">Breakpoint 2 at 0x40143a</span><br><span class="line">&gt;(gdb) run # 运行</span><br><span class="line">Starting program: &#x2F;home&#x2F;ubuntu&#x2F;cuzz&#x2F;csapp&#x2F;bomb&#x2F;bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">&gt;hello world!</span><br></pre></td></tr></table></figure>

<p>这个时候使用 <code>info registers</code> 查看寄存器信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; (gdb) info registers</span><br><span class="line">rax            0x603780            6305664</span><br><span class="line">rbx            0x402210            4203024</span><br><span class="line">rcx            0xc                 12</span><br><span class="line">rdx            0x1                 1</span><br><span class="line">rsi            0x603780            6305664</span><br><span class="line">rdi            0x603780            6305664</span><br><span class="line">rbp            0x0                 0x0</span><br><span class="line">rsp            0x7fffffffe378      0x7fffffffe378</span><br><span class="line">r8             0x603780            6305664</span><br><span class="line">r9             0x7c                124</span><br><span class="line">r10            0xfffffffffffff28e  -3442</span><br><span class="line">r11            0x7ffff7e06400      140737352066048</span><br><span class="line">r12            0x400c90            4197520</span><br><span class="line">r13            0x7fffffffe470      140737488348272</span><br><span class="line">r14            0x0                 0</span><br><span class="line">r15            0x0                 0</span><br><span class="line">rip            0x400ee0            0x400ee0 &lt;phase_1&gt;</span><br><span class="line">eflags         0x206               [ PF IF ]</span><br><span class="line">cs             0x33                51</span><br><span class="line">ss             0x2b                43</span><br><span class="line">ds             0x0                 0</span><br><span class="line">es             0x0                 0</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x0                 0</span><br></pre></td></tr></table></figure>

<p>使用 <code>disas</code> 查看执行到哪一步了，<code>stepi</code> 可以使汇编一步一步执行，具体可以看箭头变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;(gdb) disas # 反汇编</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">&#x3D;&gt; 0x0000000000400ee0 &lt;+0&gt;:    sub    $0x8,%rsp # 箭头在这里</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:    mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">Breakpoint 1, 0x0000000000400ee0 in phase_1 ()</span><br><span class="line">&gt;(gdb) stepi # 运行第一次</span><br><span class="line">0x0000000000400ee4 in phase_1 ()</span><br><span class="line">&gt;(gdb) stepi # 运行第二次</span><br><span class="line">0x0000000000400ee9 in phase_1 ()</span><br><span class="line">&gt;(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:    sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:    mov    $0x402400,%esi</span><br><span class="line">&#x3D;&gt; 0x0000000000400ee9 &lt;+9&gt;:    callq  0x401338 &lt;strings_not_equal&gt; # 运行两次，箭头像下移动两行</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>我是用 <code>x/s $rdi</code> 和 <code>x/s $rsi</code> 查看寄存器的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;(gdb) x&#x2F;s $rdi</span><br><span class="line">0x603780 &lt;input_strings&gt;:    &quot;hello world!&quot;</span><br><span class="line">&gt;(gdb) x&#x2F;s $rsi</span><br><span class="line">0x402400:    &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>

<p>就是比较这两个值是否相等，所以我们只要把这值记下来就可以拆调第一个炸弹了。</p>
<p>我们重新执行一遍，把 <code>Border relations with Canada have never been better.</code> 这段话输入进去，发现拆除了第一炸弹。</p>
<center><img src="http://img.cuzz.site/20201031233135.png" width="100%"></center>

<h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>同样我们先找到 <code>phase_2</code> 对应的汇编代码，从函数名 <code>read_six_numbers</code> 提示我们输入 6 个数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:       55                      push   %rbp</span><br><span class="line">  400efd:       53                      push   %rbx</span><br><span class="line">  400efe:       48 83 ec 28             sub    $0x28,%rsp</span><br><span class="line">  400f02:       48 89 e6                mov    %rsp,%rsi</span><br><span class="line">  400f05:       e8 52 05 00 00          callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>虽然我们知道 <code>read_six_numbers</code> 这个函数是提示我们输入 6 个数据， 但是我们不知道输入这 6 个数字的格式是怎样的，我们先输入<code>123456</code> 试试看。</p>
<p>我们先看看这个函数，对应的汇编，通过打断点 <code>break read_six_numbers</code> 进入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;(gdb) disas</span><br><span class="line">Dump of assembler code for function read_six_numbers:</span><br><span class="line">   0x000000000040145c &lt;+0&gt;:    sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401460 &lt;+4&gt;:    mov    %rsi,%rdx   # %rdx存放第一个值</span><br><span class="line">   0x0000000000401463 &lt;+7&gt;:    lea    0x4(%rsi),%rcx # %rcx &#x3D; %rsi + 0x4 放第二个值</span><br><span class="line">   0x0000000000401467 &lt;+11&gt;:    lea    0x14(%rsi),%rax # 保存在栈中 %rsi + 0x14 放第六个值</span><br><span class="line">   0x000000000040146b &lt;+15&gt;:    mov    %rax,0x8(%rsp)</span><br><span class="line">   0x0000000000401470 &lt;+20&gt;:    lea    0x10(%rsi),%rax # 保存在栈中 %rsi + 0x10 放第五个值</span><br><span class="line">   0x0000000000401474 &lt;+24&gt;:    mov    %rax,(%rsp)</span><br><span class="line">   0x0000000000401478 &lt;+28&gt;:    lea    0xc(%rsi),%r9 # %r9 &#x3D; %rsi + 0xc 放第四个值</span><br><span class="line">   0x000000000040147c &lt;+32&gt;:    lea    0x8(%rsi),%r8 # %r8 &#x3D; %rsi + 0x8 放第三个值</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:    mov    $0x4025c3,%esi</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:    mov    $0x0,%eax</span><br><span class="line">&#x3D;&gt; 0x000000000040148a &lt;+46&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt; # 一个获取输入的函数: int sscanf( const char *buffer, const char *format [, argument ] ... );</span><br><span class="line">   0x000000000040148f &lt;+51&gt;:    cmp    $0x5,%eax</span><br><span class="line">   0x0000000000401492 &lt;+54&gt;:    jg     0x401499 &lt;read_six_numbers+61&gt;</span><br><span class="line">   0x0000000000401494 &lt;+56&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401499 &lt;+61&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x000000000040149d &lt;+65&gt;:    retq</span><br><span class="line">End of assembler dump.   </span><br><span class="line">&gt;(gdb) x&#x2F;s $rsi</span><br><span class="line">0x4025c3:    &quot;%d %d %d %d %d %d&quot; # 以这种格式获取数据</span><br><span class="line">(gdb) x&#x2F;s $rdi</span><br><span class="line">&gt;0x6037d0 &lt;input_strings+80&gt;:    &quot;123456&quot; # 我们输入的数据，所以我们这样输入不对的</span><br></pre></td></tr></table></figure>

<p>首先看看第一个数是否为 1，然后循环判断后面一个数是否是前面一个数的倍数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">   0x0000000000400efc &lt;+0&gt;:    push   %rbp # 基指针</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:    push   %rbx # 基址寄存器</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:    sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:    mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">&#x3D;&gt; 0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)   # 第一个参数必须为1</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;  # 跳到52</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax # %rax &#x3D; before</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax       # %rax &#x3D; 2 * before</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)     # %rax与(%rbx)比较</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx # 循环跳出来</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx  # --&gt; 对应下面 0x04</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp # --&gt; 对应下面 0x18</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt; # 跳回到 27</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>对应内存中的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7fffffffe368  0x28        -&gt; %rbp  </span><br><span class="line">                0x24</span><br><span class="line">                0x20   </span><br><span class="line">                0x1c</span><br><span class="line">                0x18        -&gt; %rbx</span><br><span class="line">                0x14   32</span><br><span class="line">                0x10   16</span><br><span class="line">                0x0c   8</span><br><span class="line">                0x08   4</span><br><span class="line">                0x04   2</span><br><span class="line">0x7fffffffe340  0x00   1    -&gt; %rsp       </span><br></pre></td></tr></table></figure>

<p>最好我们输入 <code>1 2 4 8 16 32</code> 查看结果，就已经通过了</p>
<center><img src="http://img.cuzz.site/20201101151210.png" width="100%"></center>

<h3 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h3><p>同样我们先找到 <code>phase_3</code> 对应的汇编</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">&#x3D;&gt; 0x0000000000400f43 &lt;+0&gt;:        sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:        lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:        lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp) # 不能大于7，也不能小于0，0x8(%rsp)这个地址存放着第一个参数</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax # 把第一个参数放入%rax中</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8) # D(Rb, Ri, S) &#x3D;&gt; Mem[Reg[Rb]+S*Reg[Ri]+D] &#x3D; %rax * 8 + 0x402470</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:    mov    $0x137,%eax</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:    cmp    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:    je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">&gt;(gdb) x&#x2F;s 0x4025cf  # 查看输入格式</span><br><span class="line">0x4025cf:    &quot;%d %d&quot;</span><br><span class="line">&gt;(gdb) x&#x2F;8a 0x402470 # 对应跳转表的地址</span><br><span class="line">0x402470:    0x400f7c &lt;phase_3+57&gt;    0x400fb9 &lt;phase_3+118&gt;</span><br><span class="line">0x402480:    0x400f83 &lt;phase_3+64&gt;    0x400f8a &lt;phase_3+71&gt;</span><br><span class="line">0x402490:    0x400f91 &lt;phase_3+78&gt;    0x400f98 &lt;phase_3+85&gt;</span><br><span class="line">0x4024a0:    0x400f9f &lt;phase_3+92&gt;    0x400fa6 &lt;phase_3+99&gt;</span><br></pre></td></tr></table></figure>

<p>我们又看到 <code>sscnaf</code> 函数，<code>x/s 0x4025cf </code> 查看输入格式，发现是按 <code>%d %d</code> 输入两个数字。在 <code>&lt;+50&gt;</code> 行中是一个 switch 方法，等下 C 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x1 &gt; <span class="number">7</span> || x1 &lt; <span class="number">0</span>)</span><br><span class="line">    explode_bomb();</span><br><span class="line"><span class="keyword">switch</span>(x1) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (x2 != a)</span><br><span class="line">            explode_bomb();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (x2 != b)</span><br><span class="line">            explode_bomb();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们输入的 x1 为 1，那么对应表的地址为 <code>0x400fb9 &lt;phase_3+118&gt;</code> ，所以我们 x2 的值就是 <code>&lt;+118&gt;</code> 中的 <code>0x137</code> 对应的十进制为 311。</p>
<p>最后我们输入 <code>1 311</code> 试试，已经解除</p>
<p>了。</p>
<center><img src="http://img.cuzz.site/20201103000248.png" width="100%"></center>

<h3 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h3><p>有看到了 <code>sscanf</code> 函数，根据前面的经验，查看一下输入格式。<code>0x8(%rsp)</code> 存放着第一个值，<code>0xc(%rsp)</code> 存放着第二个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_4:</span><br><span class="line">&#x3D;&gt; 0x000000000040100c &lt;+0&gt;:    sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:    lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:    lea    0x8(%rsp),%rdx</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax # 必须为两个值</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp) # 第一个值必须小于0xe</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax # test a,b &#x3D;&gt; a &amp; b 所以func4返回的值必须为0</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp) # 第二个值必须为0</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) x&#x2F;s 0x4025cf</span><br><span class="line">0x4025cf:    &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>

<p>这里是一个递归，发现第一个数为 1 时，能是返回值为 0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function func4:</span><br><span class="line">&#x3D;&gt; 0x0000000000400fce &lt;+0&gt;:    sub    $0x8,%rsp # %rdi &#x3D; A %rsi &#x3D; B %rdx &#x3D; C</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:    mov    %edx,%eax #  %eax &#x3D; C</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:    sub    %esi,%eax #  %eax &#x3D; C - B</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:    mov    %eax,%ecx # %ecx &#x3D; C - B</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx # 右移31位 %ecx &#x3D; (C - B) &gt;&gt; 31</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax # %eax &#x3D; C - B + (C - B) &gt;&gt; 31 &#x3D; C - B</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:    sar    %eax # 等效于 sar $1,%eax   %eax &#x3D; (C - B) &#x2F; 2</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx  # %ecx &#x3D; %rax + %rsi * 1 &#x3D; (C - B) &#x2F; 2 + B &#x3D; (B + C) &#x2F; 2</span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx # 比较 A  和 %exc &#x3D;（B + C）&#x2F; 2</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt; # (B + C) &#x2F; 2 小于 A 跳转</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx # %edx &#x3D; （B + C) &#x2F; 2 - 1 </span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax # 返回 2 * %rax</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line">   0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax # %eax &#x3D; 0</span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx # 0 和 （B + C）&#x2F; 2 如果相等跳转</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt; </span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi # %esi &#x3D;（B + C）&#x2F; 2 + 1</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:    callq  0x400fce &lt;func4&gt; # 递归调用</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax # 返回 2 * %rax  + 1</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>根据 x86 汇编语言的约定，<code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code> 分别为第一、二和第三个参数使用的寄存器。<code>%rax</code> 作为返回值所在的寄存器。func4 变换为C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> step, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* edi = target; esi = step; edx = limit */</span></span><br><span class="line">    <span class="keyword">int</span> temp = (limit - step) * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = temp + step;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">        limit = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret1 = func4(target, step, limit);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * ret1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            step = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ret2 = func4(target, step, limit);</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> * ret2 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后看看测试结果</p>
<center><img src="http://img.cuzz.site/20201103202727.png" width="100%"></center>

<h3 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h3><p>先看汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&gt; 0x0000000000401062 &lt;+0&gt;:    push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:    sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:    mov    %rdi,%rbx # %rid保存输入字符串指针,复制到%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:    mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp) # 保存%rax</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax # 清零%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax  # 必须为长度为6的字符串</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx # 复制%rbx中第%rax字符串到%ecx中</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp) # %cl是%ecx低位，保存单个字符串到（%rsp）中</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx # 把字符串复制到%rdx中</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx # 取低4位</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx # 将与0x4024b0偏移量为%rdx的一个字节数据复制到%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1) # %dl是%edx的低位，将%edx最低字节复制到与%rsp偏移量为(0x10 + %rax)的栈地址中</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax # %rax值加1，值向下一个字符串</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax # 判断是否等于6，不等于继续循环</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi # %esi指向$0x40245e地址字符串</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi # 指向前面的字符串</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt; # 判断是否相等</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:    nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:    jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:    jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:    mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:    je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:    callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:    add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:    retq</span><br><span class="line">(gdb) x&#x2F;s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:    &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br><span class="line">(gdb) x&#x2F;s 0x40245e</span><br><span class="line">0x40245e:    &quot;flyers&quot;</span><br></pre></td></tr></table></figure>

<p>传入一个长度为六的字符串，依次取一个字符，截取它ASCII表上对应二进制的后四位，作为index。在 <code>maduiersnfotvbyl...</code> 这个字符串中以这个 index 为偏移量取字符。按照这样的规则从 <code>maduiersnfotvbyl...</code> 这个字符串中取出六个字符，组成新的字符串，要和 flyers 一样。这个还是很直接的吧，解题就是反过来的顺序。先根据 flyers 找出六个 index。再找个 ASCII 码表，根据 index 找到符合要求的字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br><span class="line">m a d u i e r s n f  o  t  v  b  y  l  </span><br></pre></td></tr></table></figure>

<p>所以 flyers 对应的 index 为 <code>9 15 14 5 6 7</code>，所以输入<code>ionefg</code> 就是其中一个答案。</p>
<center><img src="http://img.cuzz.site/20201105142744.png" width="80%"></center>

<p>运行一下</p>
<center><img src="http://img.cuzz.site/20201105143317.png" width="100%"></center>

<h3 id="阶段六"><a href="#阶段六" class="headerlink" title="阶段六"></a>阶段六</h3><p>先看汇编代码，这个比较长。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_6:</span><br><span class="line">&#x3D;&gt; 0x00000000004010f4 &lt;+0&gt;:    push   %r14</span><br><span class="line">   0x00000000004010f6 &lt;+2&gt;:    push   %r13</span><br><span class="line">   0x00000000004010f8 &lt;+4&gt;:    push   %r12</span><br><span class="line">   0x00000000004010fa &lt;+6&gt;:    push   %rbp</span><br><span class="line">   0x00000000004010fb &lt;+7&gt;:    push   %rbx</span><br><span class="line">   0x00000000004010fc &lt;+8&gt;:    sub    $0x50,%rsp</span><br><span class="line">   0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">   0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line">   0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt; # 读取6个值，从%rsi地址开始</span><br><span class="line">   0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14</span><br><span class="line">   0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LoopA-start</span><br><span class="line">   0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp  # %r12置0,并且%r13 %r14 %rbp 均和 %rsp 指向相同地址</span><br><span class="line">   0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax</span><br><span class="line">   0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax</span><br><span class="line">   0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax # 判断输入的数字是否为6个</span><br><span class="line">   0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">   0x0000000000401123 &lt;+47&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d # 将%r12加1，相当于index从1到5</span><br><span class="line">   0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d # 判断%r12是否等于6，等于6就跳转</span><br><span class="line">   0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;</span><br><span class="line">   0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx # 将index移到到%ebx</span><br><span class="line">   ----------------------------------------------------------- LoopB-start</span><br><span class="line">   0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax # 将%ebx移动到%rax &#x3D; index</span><br><span class="line">   0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax # 获取输入的6个值</span><br><span class="line">   0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp) # 判端(%rbp)这个值于(%rbp)的第%eax的值是否相等，不相等继续</span><br><span class="line">   0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">   0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx # index加1</span><br><span class="line">   0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx # index &lt;&#x3D; 5</span><br><span class="line">   0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt; # 跳转到65</span><br><span class="line">   ----------------------------------------------------------- LoopB-end</span><br><span class="line">   0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13 # %r13加4，指向下一个数，判断所有数都不相等</span><br><span class="line">   0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt; # 跳转到32</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LoopA-end</span><br><span class="line">   0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi #  将 %rsi 指向栈中跳过读入数据位置作为结束标记,并且 %r14 仍和 %rsp 指向同一个位置</span><br><span class="line">   0x0000000000401158 &lt;+100&gt;:    mov    %r14,%rax # 将%r14复制到%rax</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LoopC-start</span><br><span class="line">   0x000000000040115b &lt;+103&gt;:    mov    $0x7,%ecx # 将0x7复制到%exc</span><br><span class="line">   0x0000000000401160 &lt;+108&gt;:    mov    %ecx,%edx # 将0x7复制到%edx</span><br><span class="line">   0x0000000000401162 &lt;+110&gt;:    sub    (%rax),%edx # 7减去%rax地址的数，也是%rsp的第i个数</span><br><span class="line">   0x0000000000401164 &lt;+112&gt;:    mov    %edx,(%rax) # 在把这个数替换了</span><br><span class="line">   0x0000000000401166 &lt;+114&gt;:    add    $0x4,%rax # 指向下一个数</span><br><span class="line">   0x000000000040116a &lt;+118&gt;:    cmp    %rsi,%rax # 是否全部循环完了</span><br><span class="line">   0x000000000040116d &lt;+121&gt;:    jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">   &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; LoopC-end</span><br><span class="line">   0x000000000040116f &lt;+123&gt;:    mov    $0x0,%esi # 将%rsi设置为0</span><br><span class="line">   0x0000000000401174 &lt;+128&gt;:    jmp    0x401197 &lt;phase_6+163&gt; # 获取数据%ecx，和%rdx是一个地址，是一个链表</span><br><span class="line">   0x0000000000401176 &lt;+130&gt;:    mov    0x8(%rdx),%rdx # 将0x8(%rdx)存的内容复制到%rdx，指向下一个</span><br><span class="line">   0x000000000040117a &lt;+134&gt;:    add    $0x1,%eax # %eax加1</span><br><span class="line">   0x000000000040117d &lt;+137&gt;:    cmp    %ecx,%eax # %ecx和%eax 是否相等</span><br><span class="line">   0x000000000040117f &lt;+139&gt;:    jne    0x401176 &lt;phase_6+130&gt; # 不相等，继续遍历</span><br><span class="line">   0x0000000000401181 &lt;+141&gt;:    jmp    0x401188 &lt;phase_6+148&gt; # 相等，跳转到148</span><br><span class="line">   0x0000000000401183 &lt;+143&gt;:    mov    $0x6032d0,%edx # 重置链表首地址</span><br><span class="line">   0x0000000000401188 &lt;+148&gt;:    mov    %rdx,0x20(%rsp,%rsi,2) # 将%rdx的值复制到0x20(%rsp,%rsi,2)</span><br><span class="line">   0x000000000040118d &lt;+153&gt;:    add    $0x4,%rsi # 遍历下一个</span><br><span class="line">   0x0000000000401191 &lt;+157&gt;:    cmp    $0x18,%rsi</span><br><span class="line">   0x0000000000401195 &lt;+161&gt;:    je     0x4011ab &lt;phase_6+183&gt; </span><br><span class="line">   0x0000000000401197 &lt;+163&gt;:    mov    (%rsp,%rsi,1),%ecx  # 将 (%rsp + %rsi * 1) 数据复制到%ecx，我们前面构造的6个数字</span><br><span class="line">   0x000000000040119a &lt;+166&gt;:    cmp    $0x1,%ecx # 是否小于1</span><br><span class="line">   0x000000000040119d &lt;+169&gt;:    jle    0x401183 &lt;phase_6+143&gt; # 如果小于等于1，%eax指向链表首地址</span><br><span class="line">   0x000000000040119f &lt;+171&gt;:    mov    $0x1,%eax # 将%eax设置为1</span><br><span class="line">   0x00000000004011a4 &lt;+176&gt;:    mov    $0x6032d0,%edx # 将%rdx指向内存 $0x6032d</span><br><span class="line">   0x00000000004011a9 &lt;+181&gt;:    jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">   ---------------------------------------------------------</span><br><span class="line">   0x00000000004011ab &lt;+183&gt;:    mov    0x20(%rsp),%rbx # 将0x20(%rsp)链表信息复制到%rbx</span><br><span class="line">   0x00000000004011b0 &lt;+188&gt;:    lea    0x28(%rsp),%rax # 将%rax指向下一个链表</span><br><span class="line">   0x00000000004011b5 &lt;+193&gt;:    lea    0x50(%rsp),%rsi # 将%rsi指向保存链表地址的末地址</span><br><span class="line">   0x00000000004011ba &lt;+198&gt;:    mov    %rbx,%rcx</span><br><span class="line">   0x00000000004011bd &lt;+201&gt;:    mov    (%rax),%rdx</span><br><span class="line">   0x00000000004011c0 &lt;+204&gt;:    mov    %rdx,0x8(%rcx)</span><br><span class="line">   0x00000000004011c4 &lt;+208&gt;:    add    $0x8,%rax</span><br><span class="line">   0x00000000004011c8 &lt;+212&gt;:    cmp    %rsi,%rax</span><br><span class="line">   0x00000000004011cb &lt;+215&gt;:    je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">   0x00000000004011cd &lt;+217&gt;:    mov    %rdx,%rcx</span><br><span class="line">   0x00000000004011d0 &lt;+220&gt;:    jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">   ---------------------------------------------------------</span><br><span class="line">   0x00000000004011d2 &lt;+222&gt;:    movq   $0x0,0x8(%rdx)</span><br><span class="line">   0x00000000004011da &lt;+230&gt;:    mov    $0x5,%ebp</span><br><span class="line">   0x00000000004011df &lt;+235&gt;:    mov    0x8(%rbx),%rax # 将%rax指向%rbx下一个节点</span><br><span class="line">   0x00000000004011e3 &lt;+239&gt;:    mov    (%rax),%eax  </span><br><span class="line">   0x00000000004011e5 &lt;+241&gt;:    cmp    %eax,(%rbx) # 比较每个节点是否是递减</span><br><span class="line">   0x00000000004011e7 &lt;+243&gt;:    jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">   0x00000000004011e9 &lt;+245&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004011ee &lt;+250&gt;:    mov    0x8(%rbx),%rbx</span><br><span class="line">   0x00000000004011f2 &lt;+254&gt;:    sub    $0x1,%ebp</span><br><span class="line">   0x00000000004011f5 &lt;+257&gt;:    jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">   0x00000000004011f7 &lt;+259&gt;:    add    $0x50,%rsp</span><br><span class="line">   0x00000000004011fb &lt;+263&gt;:    pop    %rbx</span><br><span class="line">   0x00000000004011fc &lt;+264&gt;:    pop    %rbp</span><br><span class="line">   0x00000000004011fd &lt;+265&gt;:    pop    %r12</span><br><span class="line">   0x00000000004011ff &lt;+267&gt;:    pop    %r13</span><br><span class="line">   0x0000000000401201 &lt;+269&gt;:    pop    %r14</span><br><span class="line">   0x0000000000401203 &lt;+271&gt;:    retq</span><br><span class="line">(gdb) x&#x2F;24xw 0x006032d0</span><br><span class="line">(gdb)  x&#x2F;24xw 0x006032d0 # 链表为 12 Byte 分别为 int int 指向下一个链表的地址</span><br><span class="line">0x6032d0 &lt;node1&gt;:    0x0000014c    0x00000001    0x006032e0    0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:    0x000000a8    0x00000002    0x006032f0    0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:    0x0000039c    0x00000003    0x00603300    0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:    0x000002b3    0x00000004    0x00603310    0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:    0x000001dd    0x00000005    0x00603320    0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:    0x000001bb    0x00000006    0x00000000    0x00000000</span><br></pre></td></tr></table></figure>

<p>主要过程分为以下几步：</p>
<ul>
<li>获取 6 个数字</li>
<li>判断每个数字都大于0且小于7，并且都不相同</li>
<li>交换一下位子，arr[i] 与 arr[7-i] 的数交换一下</li>
<li>按照获取 arr 的排序的值，把对应的链表进行重新排列</li>
<li>重排之后的链表要递减</li>
</ul>
<p>最后我们看 <code>0x006032d0</code> 地址链表的值，大小顺序为<code>3 4 5 6 1 2</code> 然后我们只要输入<code>4 3 2 1 6 5</code> 就可以。</p>
<p>最后我们看看结果，发现已经全部通过了。</p>
<center><img src="http://img.cuzz.site/20201106212519.png" width="100%"></center>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完这个 lab ，学习到了 gdb 调试方法，对汇编更加深入的了解，总体来说这个实验还是挺有意思的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>深入理解计算机系统</li>
<li><a target="_blank" rel="noopener" href="https://wdxtub.com/csapp/thick-csapp-lab-2/2016/04/16/">Bomb Lab</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.scarboroughcoral.top/csapp-lab-2.html">CSAPP 之 Bomb Lab</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39722103">CSAPP bomb lab 问题</a></li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/15/CSAPP_Attack_Lab/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Attack Lab</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/20/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/"><span class="level-item">汇编入门</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "52241188a06012282b8692c32cd29b0a",
            repo: "cuzz1.github.io",
            owner: "cuzz1",
            clientID: "e829281603f9115c572d",
            clientSecret: "246dae10dfb1b363805ab98902dc93539c355bb3",
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#介绍"><span class="mr-2">1</span><span>介绍</span></a><ul class="menu-list"><li><a class="is-flex" href="#获取炸弹"><span class="mr-2">1.1</span><span>获取炸弹</span></a></li><li><a class="is-flex" href="#小技巧"><span class="mr-2">1.2</span><span>小技巧</span></a></li><li><a class="is-flex" href="#工具"><span class="mr-2">1.3</span><span>工具</span></a></li><li><a class="is-flex" href="#准备"><span class="mr-2">1.4</span><span>准备</span></a></li></ul></li><li><a class="is-flex" href="#实验部分"><span class="mr-2">2</span><span>实验部分</span></a><ul class="menu-list"><li><a class="is-flex" href="#阶段一"><span class="mr-2">2.1</span><span>阶段一</span></a></li><li><a class="is-flex" href="#阶段二"><span class="mr-2">2.2</span><span>阶段二</span></a></li><li><a class="is-flex" href="#阶段三"><span class="mr-2">2.3</span><span>阶段三</span></a></li><li><a class="is-flex" href="#阶段四"><span class="mr-2">2.4</span><span>阶段四</span></a></li><li><a class="is-flex" href="#阶段五"><span class="mr-2">2.5</span><span>阶段五</span></a></li><li><a class="is-flex" href="#阶段六"><span class="mr-2">2.6</span><span>阶段六</span></a></li></ul></li><li><a class="is-flex" href="#总结"><span class="mr-2">3</span><span>总结</span></a></li><li><a class="is-flex" href="#参考"><span class="mr-2">4</span><span>参考</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a><p class="size-small"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>