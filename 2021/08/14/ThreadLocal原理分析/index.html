<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ThreadLocal原理分析和拓展 - cuzz&#039;s blog</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="ThreadLocal原理分析和拓展"><meta property="og:url" content="https://blog.cuzz.site/2021/08/14/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://img.cuzz.site/20210814171220.png"><meta property="og:image" content="http://img.cuzz.site/20210814171235.png"><meta property="og:image" content="https://raw.githubusercontent.com/alibaba/transmittable-thread-local/master/docs/TransmittableThreadLocal-sequence-diagram.png"><meta property="article:published_time" content="2021-08-14T11:54:59.000Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="ThreadLocal"><meta property="article:tag" content="InheritableThreadLocal"><meta property="article:tag" content="TransmittableThreadLocal"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://img.cuzz.site/20210814171220.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.cuzz.site/2021/08/14/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},"headline":"cuzz's blog","image":["http://img.cuzz.site/20210814171220.png","http://img.cuzz.site/20210814171235.png","https://raw.githubusercontent.com/alibaba/transmittable-thread-local/master/docs/TransmittableThreadLocal-sequence-diagram.png"],"datePublished":"2021-08-14T11:54:59.000Z","author":{"@type":"Person","name":"John Doe"},"description":"多线程访问同一个共享变量由于线程的执行顺序和变量的可见性原因会导致并发问题，我们一般会有两种解决思路：  一是对访问的变量进行加锁处理 二是每个线程都访问本线程的变量  本次我们重点分析Java中通过ThreadLocal实现的本地变量"}</script><link rel="canonical" href="https://blog.cuzz.site/2021/08/14/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="cuzz&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/likes">Likes</a><a class="navbar-item" href="/images">Images</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-08-14T11:54:59.000Z" title="2021-08-14T11:54:59.000Z">2021-08-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">14 minutes read (About 2040 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">ThreadLocal原理分析和拓展</h1><div class="content"><p>多线程访问同一个共享变量由于线程的执行顺序和变量的可见性原因会导致并发问题，我们一般会有两种解决思路：</p>
<ul>
<li>一是对访问的变量进行加锁处理</li>
<li>二是每个线程都访问本线程的变量</li>
</ul>
<p>本次我们重点分析Java中通过ThreadLocal实现的本地变量</p>
<a id="more"></a>

<h2 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h2><p>当使用ThreadLocal维护变量的时候，该变量存储在线程的本地，其他线程无法访问，做到了线程间的隔离，也就没有线程安全的问题了。</p>
<center><img src="http://img.cuzz.site/20210814171220.png" width="80%" /></center>

<ul>
<li>每一个Thread中都会有一个ThreadLocalMap对象，</li>
<li>ThreadLocalMap 中有一个 Entry 数组</li>
<li>Entry中key是ThreadLocal对象实例 ，继承自WeakReference（弱引用），value就是我们要设置的值</li>
</ul>
<p>我们首先来看一下 ThreadLocalMap 是一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key是弱引用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始容量，必须为二的整数幂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// map中储存Entry的量</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="comment">// 总共储存了多少对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下次扩容的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下看看如何设置值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果不为空就设置值，为空就创建</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ThreadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存泄漏原因"><a href="#内存泄漏原因" class="headerlink" title="内存泄漏原因"></a>内存泄漏原因</h2><center><img src="http://img.cuzz.site/20210814171235.png" width="80%" /></center>

<ul>
<li><p>TheadLocal 本身不存储值，它只是做为一个key，来让线程从ThreadLocal中获取value</p>
</li>
<li><p>ThreadLocalMap 是使用ThreadLocal的弱引用做为key的，一个对象如果只剩下弱引用（没有强引用），该对象在GC就会被回收</p>
</li>
</ul>
<p>如果我们手动将 ThreadLocal A 的对象赋值为 null，这个 ThreadLocal A 就会被回收，ThreadLocalMap 中就会出现 key 为 null 的 Entry。</p>
<p>Java 程序没有办法访问这些 key 为 null 的Entry的value，如果当前线程迟迟不结束，使用的线程池，或者该线程需要执行一些耗时任务，在系统值就会出现一条强引用链，从 ThreadRef -&gt; Thread B -&gt; ThreadLocalMap -&gt; value -&gt; Obj C 这个value就无法回收，导致内存泄漏。</p>
<p>只有当前线程结束之后，ThreadRef 不存在栈中，强引用断开才能被回收。</p>
<p>实际上 ThreadLocal 也考虑了防护措施，在调用 ThreadLocal 的 get()、set() 方法的时候，会清除ThreadLocalMap 中 key 为 null 的值。主要调用的是 expungeStaleEntry方法。</p>
<p>避免内存泄漏的最好做法：主动调用ThreadLocal对象的 remove 方法，将ThreadLocal 对象的值删除。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/14 17:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1000</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory5M</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Memory5M</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] m = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Memory5M&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executor.execute(()-&gt; &#123;</span><br><span class="line">                threadLocal.set(<span class="keyword">new</span> Memory5M(finalI));</span><br><span class="line">                <span class="comment">// 执行</span></span><br><span class="line">                task();</span><br><span class="line">                <span class="comment">// 删除，不删除会产生内存泄漏</span></span><br><span class="line">                threadLocal.remove();</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Memory5M memory5M = threadLocal.get();</span><br><span class="line">        <span class="keyword">int</span> i = memory5M.getI();</span><br><span class="line">        System.out.printf(<span class="string">&quot;task %s process...\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="InheritableThreadLoca原理分析"><a href="#InheritableThreadLoca原理分析" class="headerlink" tit